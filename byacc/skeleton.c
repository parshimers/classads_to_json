#include "defs.h"

/*  The definition of yysccsid in the banner should be replaced with	*/
/*  a #pragma ident directive if the target C compiler supports		*/
/*  #pragma ident directives.						*/
/*									*/
/*  If the skeleton is changed, the banner should be changed so that	*/
/*  the altered version can be easily distinguished from the original.	*/
/*									*/
/*  The #defines included with the banner are there because they are	*/
/*  useful in subsequent code.  The macros #defined in the header or	*/
/*  the body either are not useful outside of semantic actions or	*/
/*  are conditional.							*/

char *banner[] =
{
    "#ifndef lint",
    "static char yysccsid[] = \"@(#)yaccpar	1.9 (Berkeley) 02/21/93\";",
    "#endif",
    "#define YYBYACC 1",
    "#define YYMAJOR 1",
    "#define YYMINOR 9",
    "#define yyclearin (yychar=(-1))",
    "#define yyerrok (yyerrflag=0)",
    "#define YYRECOVERING (yyerrflag!=0)",
    0
};

char *jbanner[] =
{
    "// This file created by byacc/java",
    "// Based on Berkeley yacc version 1.9.",
    "// Java support added by Marvin Solomon (solomon@cs.wisc.edu)",
    "// Based on ideas from Bob Jamison (rjamison@lincom-asg.com).",
    "// $Revision: 1.7 $",
    "// $Date: 2003/01/13 19:57:57 $",
    0
};

char *tables[] =
{
    "extern short yylhs[];",
    "extern short yylen[];",
    "extern short yydefred[];",
    "extern short yydgoto[];",
    "extern short yysindex[];",
    "extern short yyrindex[];",
    "extern short yygindex[];",
    "extern short yytable[];",
    "extern short yycheck[];",
    "#if YYDEBUG",
    "extern char *yyname[];",
    "extern char *yyrule[];",
    "#endif",
    0
};


char *header[] =
{
    "#ifdef YYSTACKSIZE",
    "#undef YYMAXDEPTH",
    "#define YYMAXDEPTH YYSTACKSIZE",
    "#else",
    "#ifdef YYMAXDEPTH",
    "#define YYSTACKSIZE YYMAXDEPTH",
    "#else",
    "#define YYSTACKSIZE 500",
    "#define YYMAXDEPTH 500",
    "#endif",
    "#endif",
    "int yydebug;",
    "int yynerrs;",
    "int yyerrflag;",
    "int yychar;",
    "short *yyssp;",
    "YYSTYPE *yyvsp;",
    "YYSTYPE yyval;",
    "YYSTYPE yylval;",
    "short yyss[YYSTACKSIZE];",
    "YYSTYPE yyvs[YYSTACKSIZE];",
    "#define yystacksize YYSTACKSIZE",
    0
};


char *body[] =
{
    "#define YYABORT goto yyabort",
    "#define YYREJECT goto yyabort",
    "#define YYACCEPT goto yyaccept",
    "#define YYERROR goto yyerrlab",
    "int",
    "yyparse()",
    "{",
    "    int yym, yyn, yystate;",
    "#if YYDEBUG",
    "    char *yys;",
    "    extern char *getenv();",
    "",
    "    if (yys = getenv(\"YYDEBUG\"))",
    "    {",
    "        yyn = *yys;",
    "        if (yyn >= '0' && yyn <= '9')",
    "            yydebug = yyn - '0';",
    "    }",
    "#endif",
    "",
    "    yynerrs = 0;",
    "    yyerrflag = 0;",
    "    yychar = (-1);",
    "",
    "    yyssp = yyss;",
    "    yyvsp = yyvs;",
    "    *yyssp = yystate = 0;",
    "",
    "yyloop:",
    "    if (yyn = yydefred[yystate]) goto yyreduce;",
    "    if (yychar < 0)",
    "    {",
    "        if ((yychar = yylex()) < 0) yychar = 0;",
    "#if YYDEBUG",
    "        if (yydebug)",
    "        {",
    "            yys = 0;",
    "            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
    "            if (!yys) yys = \"illegal-symbol\";",
    "            printf(\"%sdebug: state %d, reading %d (%s)\\n\",",
    "                    YYPREFIX, yystate, yychar, yys);",
    "        }",
    "#endif",
    "    }",
    "    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&",
    "            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)",
    "    {",
    "#if YYDEBUG",
    "        if (yydebug)",
    "            printf(\"%sdebug: state %d, shifting to state %d\\n\",",
    "                    YYPREFIX, yystate, yytable[yyn]);",
    "#endif",
    "        if (yyssp >= yyss + yystacksize - 1)",
    "        {",
    "            goto yyoverflow;",
    "        }",
    "        *++yyssp = yystate = yytable[yyn];",
    "        *++yyvsp = yylval;",
    "        yychar = (-1);",
    "        if (yyerrflag > 0)  --yyerrflag;",
    "        goto yyloop;",
    "    }",
    "    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&",
    "            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)",
    "    {",
    "        yyn = yytable[yyn];",
    "        goto yyreduce;",
    "    }",
    "    if (yyerrflag) goto yyinrecovery;",
    "#ifdef lint",
    "    goto yynewerror;",
    "#endif",
    "yynewerror:",
    "    yyerror(\"syntax error\");",
    "#ifdef lint",
    "    goto yyerrlab;",
    "#endif",
    "yyerrlab:",
    "    ++yynerrs;",
    "yyinrecovery:",
    "    if (yyerrflag < 3)",
    "    {",
    "        yyerrflag = 3;",
    "        for (;;)",
    "        {",
    "            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&",
    "                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)",
    "            {",
    "#if YYDEBUG",
    "                if (yydebug)",
    "                    printf(\"%sdebug: state %d, error recovery shifting\\",
    " to state %d\\n\", YYPREFIX, *yyssp, yytable[yyn]);",
    "#endif",
    "                if (yyssp >= yyss + yystacksize - 1)",
    "                {",
    "                    goto yyoverflow;",
    "                }",
    "                *++yyssp = yystate = yytable[yyn];",
    "                *++yyvsp = yylval;",
    "                goto yyloop;",
    "            }",
    "            else",
    "            {",
    "#if YYDEBUG",
    "                if (yydebug)",
    "                    printf(\"%sdebug: error recovery discarding state %d\
\\n\",",
    "                            YYPREFIX, *yyssp);",
    "#endif",
    "                if (yyssp <= yyss) goto yyabort;",
    "                --yyssp;",
    "                --yyvsp;",
    "            }",
    "        }",
    "    }",
    "    else",
    "    {",
    "        if (yychar == 0) goto yyabort;",
    "#if YYDEBUG",
    "        if (yydebug)",
    "        {",
    "            yys = 0;",
    "            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
    "            if (!yys) yys = \"illegal-symbol\";",
    "            printf(\"%sdebug: state %d, error recovery discards token %d\
 (%s)\\n\",",
    "                    YYPREFIX, yystate, yychar, yys);",
    "        }",
    "#endif",
    "        yychar = (-1);",
    "        goto yyloop;",
    "    }",
    "yyreduce:",
    "#if YYDEBUG",
    "    if (yydebug)",
    "        printf(\"%sdebug: state %d, reducing by rule %d (%s)\\n\",",
    "                YYPREFIX, yystate, yyn, yyrule[yyn]);",
    "#endif",
    "    yym = yylen[yyn];",
    "    yyval = yyvsp[1-yym];",
    "    switch (yyn)",
    "    {",
    0
};

char *jbody[] = {
    "/** Set to true if parsing actions should be traced. */",
    "/*package*/ boolean tracing = false;",
    "",
    "/** If true, accept when a prefix of the input matches. */",
    "/*package*/ boolean acceptPrefix = false;",
    "",
    "/** Flag used in error recovery.",
    " * Number of tokens that must be successfully scanned before leaving",
    " * error-recovery mode.",
    " */",
    "private int errorLookahead;",
    "",
    "/** Last token read by lex.  The special value -1 means there is no",
    " * current lookahead.",
    " */",
    "private int lookahead = -1;",
    "",
    "/** The current LALR parser state.",
    " *  Invariant:  state == stateStack[stackTop]",
    " */",
    "private int state;",
    "",
    "/** Fixed maximum size for the parse and value stacks (currently 500).",
    " * This should be more than enough unless the grammar uses right-recursive",
    " * rules to parse a very long list, for example",
    " * <pre>",
    " *       list : element | element ',' list ;",
    " * </pre>",
    " * on input",
    " * <pre>",
    " *       a, a, a, a, ... [500 elements in all]",
    " * </pre>",
    " * If the stack overflows, an ArrayIndexOutOfBoundsException will be thrown.",
    " */",
    "private final static int STACKSIZE = 500;",
    "",
    "/** Stack of parser states.",
    " *  Invariant:  state == stateStack[stackTop]",
    " */",
    "private int stateStack[] = new int[STACKSIZE];",
    "",
    "/** Stack of semantic values, parallel to stateStack */",
    "private Object valStack[] = new Object[STACKSIZE];",
    "",
    "/** Index in stateStack of the top (highest-numbered) element of the stack. */",
    "private int stackTop = -1;",
    "",
    "/** The semantic value associated with the LHS of the last production */",
    "private Object val;",
    "",
    "/** The semantic value associated with the last token returned by lex() */",
    "private Object lval;",
    "",
    "/** Print a message to System.out if tracing is true.",
    " * @param msg the message to print.",
    " */",
    "private void trace(Object msg) {",
    "    if (tracing) {",
    "        System.out.println(msg);",
    "    }",
    "} // trace(Object)",
    "",
    "/** Convert the current stack into a string (top of stack at right).",
    " * @return string version of current stack.",
    " */",
    "private String showStack() {",
    "    if (stackTop < 0) {",
    "        return \"EMPTY\";",
    "    }",
    "    StringBuffer sb = new StringBuffer(Integer.toString(stateStack[0]));",
    "    for (int i = 1; i <= stackTop; i++) {",
    "        sb.append(\" \" + stateStack[i]);",
    "    }",
    "    return sb.toString();",
    "} // showStack()",
    "",
    "/** Translate a token number to a name.",
    " * @param token the code for a token.",
    " * @return the name of the token.",
    " */",
    "private String tokenName(int token) {",
    "    if (token == ERROR_TOKEN) {",
    "        return \"$error$\";",
    "    }",
    "    if (token < 0 || token >= name.length) {",
    "        return \"<unknown_token>\";",
    "    }",
    "    if (name[token] != null) {",
    "        return name[token];",
    "    }",
    "    if (token > 32 && token < 127) {",
    "        return \"'\" + (char)token + \"'\";",
    "    }",
    "    return \"<unknown_token>\";",
    "} // tokenName(int)",
    "",
    "/** Generate a list of all tokens that can be accepted in the current state.",
    " * This method is only used for printing error messages, so it doesn't have",
    " * to be particularly fast.",
    " * @return an array of token codes.",
    " */",
    "private int[] validTokens(int state) {",
    "    // Count how many there are.",
    "    int count = 0;",
    "    for (int token = 0; token <= name.length; token++) {",
    "        if (token == ERROR_TOKEN) {",
    "            continue;",
    "        }",
    "        if (tableLookup(sindex, state, token) >= 0",
    "            || tableLookup(rindex, state, token) >= 0)",
    "        {",
    "            count++;",
    "        }",
    "    }",
    "",
    "    // Gather the results.",
    "    int[] result = new int[count];",
    "    int i = 0;",
    "    for (int token = 0; token <= name.length; token++) {",
    "        if (token == ERROR_TOKEN) {",
    "            continue;",
    "        }",
    "        if (tableLookup(sindex, state, token) >= 0",
    "            || tableLookup(rindex, state, token) >= 0)",
    "        {",
    "            result[i++] = token;",
    "        }",
    "    }",
    "    return result;",
    "} // validTokens(int)",
    "",
    "/** Look up a value in a compressed version of a two-dimentsional array",
    " * of positive integers.",
    " * The two-dimensional tables generated by byacc are compressed by packing",
    " * them in to a pair of parallel long arrays check[] and table[].",
    " * The virtual array V[x,y] is represented by mapping rows to contiguous",
    " * slices of table[] as indicated by the array start[].  Each row of",
    " * V[,] starts at offset start[row] in table[].  Thus the value",
    " * V[row,column] is stored in table[start[row] + column].  However,",
    " * the array V is sparse, and slots corresponding to \"missing\" elements of",
    " * V[,] may be used by other rows (or even other arrays).  The element",
    " * table[start[row] + column] actually contains V[row,column] if and",
    " * only if the corresponding element of check[] contains column:",
    " *   table[start[row] + column] == column.",
    " * A row of V that is entirely missing is represented by start[row]==0.",
    " * @param start a mapping from rows of V to offsets within table[] and",
    " * check[].",
    " * @param row the desired row of V.",
    " * @param column the resired column of V.",
    " * @return the value of V[row,column] if that element exists.  Otherwise,",
    " * return -1.",
    " */",
    "private static final int tableLookup(short[] start, int row, int column) {",
    "    int offset = start[row];",
    "    if (offset == 0) {",
    "        return -1;",
    "    }",
    "    offset += column;",
    "    if (offset < 0) {",
    "        return -1;",
    "    }",
    "    if (offset >= check.length) {",
    "        return -1;",
    "    }",
    "    if (check[offset] != column) {",
    "        return -1;",
    "    }",
    "    return table[offset];",
    "} // tableLookup(short[],int,int)",
    "",
    "/** Check whether the the unconsumed input is a syntactically valid phrase",
    " * according to the grammar.",
    " * Parsing stops at the end of the input, or the first token that cannot",
    " * be included in a prefix of a valid ",
    " * phrase according to the grammar.  If \"acceptPrefix\" is false and an",
    " * invalid token is encountered before the end of the input, an error occurs.",
    " * An error is also signaled if \"acceptPrefix\" is true but the input preceding",
    " * the invalid token is not a valid phrase according the the grammar.",
    " * <p>",
    " * If the input is already at end of file when this method is called, it",
    " * silently returns null.",
    " * If an error occurs, a message is printed by calling the user-supplied",
    " * method error(String) and the result is null.   On success, the return value",
    " * is the \"semantic value\" assigned by semantic routines to the start symbol.",
    " *",
    " * @param acceptPrefix if true, the input does not to be completely consumed.",
    " * @return the \"semantic value\" corresponding to the phrase found or null for",
    " * errors or end-of-file.",
    " */",
    "public Object parse(boolean acceptPrefix) {",
    "    this.acceptPrefix = acceptPrefix;",
    "    errorLookahead = 0;",
    "    stackTop = 0;",
    "    state = 0;",
    "    stateStack[stackTop] = 0;",
    "",
    "    //outer loop: until parsing is done, either correctly, or w/error",
    "    for (;;) {",
    "        int prod; // set by the inner loop to the number of a production",
    "        int nextState;",
    "",
    "        // inner loop: figure out whether to shift or reduce",
    "        for (;;) {",
    "            // First check whether this is a \"default-reduce\" state (i.e.,",
    "            // whether this state has only one action, which is to reduce by a",
    "            // particular production).  If so, we don't even look at the next",
    "            // token.",
    "            prod = defred[state];",
    "            if (prod != 0) {",
    "                if (tracing) {",
    "                    trace(\"Stack \" + showStack()",
    "                                + \" default action is reduce by \" + prod);",
    "                }",
    "                break;",
    "            }",
    "",
    "            // Get a lookahead token",
    "            if (lookahead < 0) {",
    "                lookahead = lex();",
    "            }",
    "            if (state == 0 && lookahead == 0) {",
    "                // Nothing left to parse; just return null",
    "                if (tracing) {",
    "                    trace(\"Null input\");",
    "                }",
    "                return null;",
    "            }",
    "            if (tracing) {",
    "                trace(\"Stack \" + showStack()",
    "                            + \" token \" + lookahead",
    "                            + \" (\" + tokenName(lookahead) + \")\");",
    "            }",
    "",
    "            // Check for a shift action on this token",
    "            nextState = tableLookup(sindex, state, lookahead);",
    "            if (nextState >= 0) {",
    "                state = nextState;",
    "                stateStack[++stackTop] = state;",
    "                valStack[stackTop] = lval;",
    "                lookahead = -1;",
    "                if (tracing) {",
    "                    trace(\"shift to stack \" + showStack());",
    "                }",
    "                // If we are recovering from an error, decrement the number of",
    "                // tokens that have to be consumed before leaving recovery",
    "                // status.",
    "                if (errorLookahead > 0) {",
    "                    --errorLookahead;",
    "                }",
    "                prod = -1;",
    "                break;",
    "            }",
    "",
    "            // Check for a reduce action on this token",
    "            prod = tableLookup(rindex, state, lookahead);",
    "            if (prod > 0) {",
    "                break;",
    "            }",
    "",
    "            // This point is only reached on an error (no shift or reduce",
    "            // action for this state and lookahead).",
    "",
    "            if (acceptPrefix) {",
    "                // See if what we've seen so far would be accepted if the",
    "                // lookhead were EOF.",
    "                for (;;) {",
    "                    if (tracing)",
    "                        trace(\"Stack \" + showStack()",
    "                            + \": pretend lookhead EOF\");",
    "                    prod = defred[state];",
    "                    if (prod != 0) {",
    "                        if (tracing) {",
    "                            trace(\"Default action is reduce by \" + prod);",
    "                        }",
    "                    } else {",
    "                        prod = tableLookup(rindex, state, 0);",
    "                        if (tracing) {",
    "                            trace(\"Reduce by \" + prod + \" at EOF\");",
    "                        }",
    "                    }",
    "                    if (prod <= 0) {",
    "                        break;",
    "                    }",
    "                    reduceBy(prod);",
    "                }",
    "            }",
    "            if (state == FINAL_STATE && (acceptPrefix || lookahead == 0)) {",
    "                if (tracing) {",
    "                    trace(\"Prefix matches\");",
    "                }",
    "                // At this point, the input scanned thus far is a maximal",
    "                // match for the start symbol of the grammar -- that is,",
    "                // no more tokens can be consumed.  We return an indication",
    "                // of success, and the caller can determine whether there",
    "                // is more to consume by testing for nextToken() == 0.",
    "                return val;",
    "            }",
    "",
    "            // ************ Error Recovery *********************",
    "            if (errorLookahead==0)",
    "            {",
    "                // suppress this message if we are already in error-recovery",
    "                // mode",
    "                error(\"syntax error\");",
    "            }",
    "            if (errorLookahead < 3) {",
    "                // Pop states util we find one that can accept the \"error\"",
    "                // token",
    "                errorLookahead = 3;",
    "                for (;;) {",
    "                    if (stackTop<0) {",
    "                        if (tracing) {",
    "                            trace(\"Recovery deletes all left context\");",
    "                        }",
    "                        return null;",
    "                    }",
    "                    nextState = tableLookup(sindex,",
    "                                  stateStack[stackTop], ERROR_TOKEN);",
    "                    if (nextState >= 0) {",
    "                        if (tracing) {",
    "                            trace(\"Stack \" + showStack()",
    "                                + \", error recovery shifting to state \"",
    "                                + nextState);",
    "                        }",
    "                        state = nextState;",
    "                        stateStack[++stackTop] = state;",
    "                        valStack[stackTop] = lval;",
    "                        prod = -1;",
    "                        break;",
    "                    }",
    "                    if (tracing) {",
    "                        trace(\"error recovery discarding state \"",
    "                            + stateStack[stackTop]);",
    "                    }",
    "                    if (stackTop<0) {",
    "                        if (tracing) {",
    "                            trace(\"Recovery deletes all left context\");",
    "                        }",
    "                        return null;",
    "                    }",
    "                    stackTop--;",
    "                }",
    "            } else { // errorLookahead == 3",
    "                if (lookahead == 0) {",
    "                    // Cannot recover",
    "                    trace(\"Recovery hits EOF\");",
    "                    return null;",
    "                }",
    "                if (tracing) {",
    "                    trace(\"Stack \" + showStack()",
    "                        + \", error recovery discards token \" + lookahead",
    "                        + \"(\" + tokenName(lookahead) + \")\");",
    "                }",
    "                lookahead = -1;  //read another",
    "            }",
    "            // ************ End of Error Recovery *********************",
    "        } // inner loop",
    "        if (prod > 0) {",
    "            // perform a reduction",
    "            reduceBy(prod);",
    "            if (state == FINAL_STATE) {",
    "                if (lookahead < 0) {",
    "                    lookahead = lex();",
    "                }",
    "            }",
    "        }",
    "    } // main loop",
    "} // parse(boolean)",
    "",
    "/** Check whether the the unconsumed input is a syntactically valid phrase",
    " * according to the grammar.",
    " * This method is equivalent to parse(true).",
    " * @return the \"semantic value\" corresponding to the phrase found or null for",
    " * errors or end-of-file.",
    " */",
    "public Object parse() {",
    "    return parse(true);",
    "} // parse()",
    "",
    "/** Turn debug tracing on or off.",
    " * Debugging output goes to System.out.",
    " * @param on if true, turn tracing on; otherwise turn it off.",
    " * @return the previous value.",
    " */",
    "public boolean enableTracing(boolean on) {",
    "    boolean result = tracing;",
    "    tracing = on;",
    "    return result;",
    "} // enableTracing(boolean)",
    "",
    "/** Perform the syntactic and semantic actions associated with a \"reduction\"",
    " * step.",
    " * @param prod the production to be used.",
    " */",
    "private void reduceBy(int prod) {",
    "    // Perform the semantic action associated with prod",
    "    if (tracing) {",
    "        trace(\"reduce by production \" + prod",
    "            + \" [\" + rule[prod] + \"]\");",
    "    }",
    "    int rhsLength = len[prod];",
    "",
    "    // The default action is $$ = $1",
    "    val = valStack[stackTop - rhsLength + 1];",
    "",
    "    switch(prod) {",
    "        //########## USER-SUPPLIED ACTIONS ##########",
    0
};

char *trailer[] =
{
    "    }",
    "    yyssp -= yym;",
    "    yystate = *yyssp;",
    "    yyvsp -= yym;",
    "    yym = yylhs[yyn];",
    "    if (yystate == 0 && yym == 0)",
    "    {",
    "#if YYDEBUG",
    "        if (yydebug)",
    "            printf(\"%sdebug: after reduction, shifting from state 0 to\\",
    " state %d\\n\", YYPREFIX, YYFINAL);",
    "#endif",
    "        yystate = YYFINAL;",
    "        *++yyssp = YYFINAL;",
    "        *++yyvsp = yyval;",
    "        if (yychar < 0)",
    "        {",
    "            if ((yychar = yylex()) < 0) yychar = 0;",
    "#if YYDEBUG",
    "            if (yydebug)",
    "            {",
    "                yys = 0;",
    "                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
    "                if (!yys) yys = \"illegal-symbol\";",
    "                printf(\"%sdebug: state %d, reading %d (%s)\\n\",",
    "                        YYPREFIX, YYFINAL, yychar, yys);",
    "            }",
    "#endif",
    "        }",
    "        if (yychar == 0) goto yyaccept;",
    "        goto yyloop;",
    "    }",
    "    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&",
    "            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)",
    "        yystate = yytable[yyn];",
    "    else",
    "        yystate = yydgoto[yym];",
    "#if YYDEBUG",
    "    if (yydebug)",
    "        printf(\"%sdebug: after reduction, shifting from state %d \\",
    "to state %d\\n\", YYPREFIX, *yyssp, yystate);",
    "#endif",
    "    if (yyssp >= yyss + yystacksize - 1)",
    "    {",
    "        goto yyoverflow;",
    "    }",
    "    *++yyssp = yystate;",
    "    *++yyvsp = yyval;",
    "    goto yyloop;",
    "yyoverflow:",
    "    yyerror(\"yacc stack overflow\");",
    "yyabort:",
    "    return (1);",
    "yyaccept:",
    "    return (0);",
    "}",
    0
};

char *jtrailer[] = {
    "        //########## END OF USER-SUPPLIED ACTIONS ##########",
    "    }//switch",
    "",
    "    if (tracing) {",
    "        trace(\"Pop \" + rhsLength",
    "            + \" state\" + (rhsLength==1 ? \"\" : \"s\")",
    "            + \" from stack \" + showStack());",
    "    }",
    "    stackTop -= rhsLength;",
    "    state = stateStack[stackTop];",
    "    int target = lhs[prod];",
    "",
    "    // Check for special reduction <start> : <empty> in state 0",
    "    if (state == 0 && rhsLength == 0) {",
    "        trace(\"Special EOF case: shifting state \" + FINAL_STATE);",
    "        //explicitly say we're done",
    "        state = FINAL_STATE;",
    "    } else {",
    "        // Consult goto tables (sort of like a shift action)",
    "        int nextState = tableLookup(gindex, target, state);",
    "        if (nextState >= 0) {",
    "            // nextState = goto[LHS, state]",
    "            if (tracing) {",
    "                trace(\"Goto(\" + showStack()",
    "                    + \",\" + ntname[target]",
    "                    + \") = \" + nextState);",
    "            }",
    "            state = nextState;",
    "        } else {",
    "            // default goto: nextState = dgoto[LHS]",
    "            if (tracing) {",
    "                trace(\"DefaultGoto(\" + ntname[target]",
    "                    + \") = \" + dgoto[target]);",
    "            }",
    "            state = dgoto[target];",
    "        }",
    "    }",
    "    stateStack[++stackTop] = state;",
    "    valStack[stackTop] = val;",
    "} // reduceBy(int,int)",
    "",
    0
};

static struct sect_info {
    char **addr;
    char *name;
} info[] = {
    { tables, "tables" },
    { header, "header" },
    { body, "body" },
    { jbody, "jbody" },
    { trailer, "trailer" },
    { jtrailer, "jtrailer" },
    { banner, "banner" },
    { jbanner, "jbanner" },
    { 0, 0}
};

int dump_section(char *name) {
    struct sect_info *p;
    for (p = info; p->addr; p++) {
	if (strcmp(name, p->name) == 0) {
	    char **s;
	    FILE *f = fopen(p->name, "w");
	    if (f == 0) {
		perror(p->name);
		exit(1);
	    }
	    for (s = p->addr; *s; s++)
		fprintf(f, "%s\n", *s);
	    return 1;
	}
    }
    fprintf(stderr, "no section named '%s'\n", name);
    return 0;
}
    

void write_section(char *section[])
{
    FILE *f;
    FILE *skel = 0;
    char *libdir = getenv("YACC_LIB");
    char buf[1000];

    f = code_file;
    if (libdir) {
	struct sect_info *p;
	strcpy(buf, libdir);
	strcat(buf, "/");
	for (p = info; p->addr; p++) {
	    if (section == p->addr) {
		strcat(buf, p->name);
		skel = fopen(buf, "r");
		break;
	    }
	}
    }
    if (skel)
    {
	while (fgets(buf, sizeof buf, skel))
	{
	    ++outline;
	    fprintf(f, "%s", buf);
	}
    }
    else
    {
	while (*section)
	{
	    ++outline;
	    fprintf(f, "%s\n", *section++);
	}
    }
}
