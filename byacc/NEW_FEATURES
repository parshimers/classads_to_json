     The -r option has been implemented.  The -r option tells Yacc to
put the read-only tables in y.tab.c and the code and variables in
y.code.c.  Keith Bostic asked for this option so that :yyfix could be
eliminated.

     The -l and -t options have been implemented.  The -l option tells
Yacc not to include #line directives in the code it produces.  The -t
option causes debugging code to be included in the compiled parser.

     The code for error recovery has been changed to implement the same
algorithm as AT&T Yacc.  There will still be differences in the way
error recovery works because AT&T Yacc uses more default reductions
than Berkeley Yacc.

     The environment variable TMPDIR determines the directory where
temporary files will be created.  If TMPDIR is defined, temporary files
will be created in the directory whose pathname is the value of TMPDIR.
By default, temporary files are created in /tmp.

     The keywords are now case-insensitive.  For example, %nonassoc,
%NONASSOC, %NonAssoc, and %nOnAsSoC are all equivalent.

     Commas and semicolons that are not part of C code are treated as
commentary.

     Line-end comments, as in BCPL, are permitted.  Line-end comments
begin with // and end at the next end-of-line.  Line-end comments are
permitted in C code; they are converted to C comments on output.

     The form of y.output files has been changed to look more like
those produced by AT&T Yacc.

     A new kind of declaration has been added.  The form of the declaration
is

	  %ident string

where string is a sequence of characters begining with a double quote
and ending with either a double quote or the next end-of-line, whichever
comes first.  The declaration will cause a #ident directive to be written
near the start of the output file.

     If a parser has been compiled with debugging code, that code can be
enabled by setting an environment variable.  If the environment variable
YYDEBUG is set to 0, debugging output is suppressed.  If it is set to 1,
debugging output is written to standard output.

-------------------------------------------------------
Marvin Solomon, University of Wisconsin (solomon@cs.wisc.edu), January, 1999.

Java support was added.  If -j is specified, the output will be a 
Java class declaration.  The prolog of the .y file should generate
a class header as well as anything that should precede it in the generated
Java program.  For example,
    %{
    package COM.bigcorp.parser;
    import java.io.*;
    import java.util.*;
    public class Parser extends Thread {
    %}
Note that Java requires the name of the file to match the name of the
class it defines.  Thus if you choose a different name for this class,
you must use the -b flag to change the name of the output file.
IMPORTANT:  This prolog contains an unbalanced open brace.  The epilog
(after the second %% line) must contain a matching close brace, since
all braces in code generated by yacc is balanced.

Yacc will generate a series of field and method declarations, the most
important of which is
    public boolean parse() {
	...
    }
All other fields and attribute will have default (package) scope (i.e.,
neither public, protected, nor private).

The epilog (after the second %% line in the .y file) is copied verbatim
from the .y file to the output (.java) file after the body of parse().
Note that this is different from the C version, where the epilog is placed
before yyparse().  The epilog should include any additional fields and methods,
including constructors, and should end with the right brace matching the class
header in the prolog.  It must include methods
    int lex() { ... }
and
    void error() { ... }
The lex method returns a token code and, as a side-effect, assigns a value to
the field lval, which is declared as
    Object lval;
Example:
    %%
    private Reader input;
    Parser(Reader input) { this.input = input; }
    int lex() { ... }
    void yyerror() { ... }

[NB: if the -p flag is specified, the names of _all_ generated members
are prefixed by this string.  Thus, for example, if yacc is invoked as
    yacc -j -syy foo.y
the lexer should be named yylex, and it should assign the semantic value
to yylval.  The default prefix for Java parsers is the empty string rather
than yy, since the class scope already prevents name clashes with other
code.]

The semantic value returned by lex(), as well as the semantic values
associated with all non-terminals (stored internally in the field "val")
are Objects; there is no support for semantic values of a primitive type
such as int or float, although you can use Integer or Float if you like.

Type declarations, if supplied, turn into casts in the generated code.
For example, given the declaration
    %type <Float> Expr
and a production like
    Expr : Expr '+' Expr {
	$$ = new Float($1.floatValue() + $3.floatValue());
    }
the string '$1' is translated to something like
    ((Float)valStack[stackTop - 2])

Any %union declarations are ignored (with a warning).

//-style comments in the prolog or actions are not converted to /* ... */
style (but they are recognized as comments).

I also added the facility for taking the parser "boiler plate" from a file
rather than compiled-in tables.  If the environment variable YACC_LIB
is defined and the files jheader and/or jbody exist in that directory,
they will be used rather than the compiled-in tables by those names
in output.c.  I added this feature to make it easier to fiddle with the
parser while debugging it. For production use, it's probably better to
have just one a.out to install.
