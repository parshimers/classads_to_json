// This file created by byacc/java
// Based on Berkeley yacc version 1.9.
// Java support added by Marvin Solomon (solomon@cs.wisc.edu)
// Based on ideas from Bob Jamison (rjamison@lincom-asg.com).
// $Revision: 1.8 $
// $Date: 2005/05/06 20:54:07 $
//line 2 "classad.y"
/* **************************Copyright-DO-NOT-REMOVE-THIS-LINE**
 * Condor Copyright Notice
 *
 * See LICENSE.TXT for additional notices and disclaimers.
 *
 * Copyright (c)1990-2005 Condor Team, Computer Sciences Department,
 * University of Wisconsin-Madison, Madison, WI.  All Rights Reserved.
 * Use of the CONDOR Software Program Source Code is authorized
 * solely under the terms of the Condor Public License (see LICENSE.TXT).
 * For more information contact:
 * CONDOR Team, Attention: Professor Miron Livny,
 * 7367 Computer Sciences, 1210 W. Dayton St., Madison, WI 53706-1685,
 * (608) 262-0856 or miron@cs.wisc.edu.
 * ***************************Copyright-DO-NOT-REMOVE-THIS-LINE**/

package condor.classad;
import java.io.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
/** This is the internal classad parser generated by byacc.  From outside
 * this package, it should be accessed through the wrapper class ClassAdParser.
 * @see ClassAdParser
 * @author <a href="mailto:solomon@cs.wisc.edu">Marvin Solomon</a>
 * @version 2.0
 */
class Parser {
//line 37 "Parser.java"
/** Internal code for a token. */
public static final short ERROR = 257;
/** Internal code for a token. */
public static final short FALSE = 258;
/** Internal code for a token. */
public static final short IDENTIFIER = 259;
/** Internal code for a token. */
public static final short INTEGER = 260;
/** Internal code for a token. */
public static final short LEX_ERROR = 261;
/** Internal code for a token. */
public static final short REAL = 262;
/** Internal code for a token. */
public static final short STRING = 263;
/** Internal code for a token. */
public static final short TRUE = 264;
/** Internal code for a token. */
public static final short UNDEFINED = 265;
/** Internal code for a token. */
public static final short OP_LOR = 266;
/** Internal code for a token. */
public static final short OP_LAND = 267;
/** Internal code for a token. */
public static final short OP_EQ = 268;
/** Internal code for a token. */
public static final short OP_NE = 269;
/** Internal code for a token. */
public static final short OP_IS = 270;
/** Internal code for a token. */
public static final short OP_ISNT = 271;
/** Internal code for a token. */
public static final short OP_LE = 272;
/** Internal code for a token. */
public static final short OP_GE = 273;
/** Internal code for a token. */
public static final short OP_SHL = 274;
/** Internal code for a token. */
public static final short OP_SHR = 275;
/** Internal code for a token. */
public static final short OP_SHRR = 276;
/** Internal code for a token. */
public static final short UNARY = 277;
private final static short ERROR_TOKEN = 256;
private final static short lhs[] = {                                        -1,
    0,    0,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    2,    2,    2,    2,    2,    3,
    3,    3,    4,    4,    4,    4,    4,    4,    8,    8,
   13,   13,    9,    9,    7,    7,   14,   14,   10,   10,
    6,    6,    5,    5,    5,    5,    5,    5,    5,   12,
   12,   11,
};
private final static short len[] = {                                         2,
    1,    5,    3,    3,    3,    3,    3,    3,    3,    3,
    3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
    3,    3,    3,    1,    1,    2,    2,    2,    2,    1,
    3,    4,    1,    1,    1,    1,    1,    3,    3,    2,
    1,    2,    1,    3,    3,    2,    1,    2,    3,    5,
    4,    3,    1,    1,    1,    1,    1,    1,    1,    1,
    2,    1,
};
private final static short defred[] = {                                      0,
   59,   57,   62,   55,   53,   60,   56,   58,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   24,    0,   30,
   34,   37,   36,   35,    0,    0,   26,   27,   28,   29,
   47,    0,    0,    0,   46,    0,   41,    0,   43,    0,
   40,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   61,   48,    0,   45,
    0,   38,   42,    0,   39,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   21,   22,   23,    0,   31,    0,   52,
    0,    0,   49,   44,    0,   32,   51,    0,    0,    2,
   50,
};
private final static short dgoto[] = {                                      39,
   17,   18,   19,   20,   21,   22,   23,   24,   40,   33,
   25,   26,   41,   35,
};
private final static short sindex[] = {                                    991,
    0,    0,    0,    0,    0,    0,    0,    0,  991,  991,
  991,  991,  -59,  991,  923,    0,  804,    0,  -38,    0,
    0,    0,    0,    0,  -36, -258,    0,    0,    0,    0,
    0,  -84,  -44,  -51,    0,  -21,    0, -108,    0,  -42,
    0,  991,  991,  991,  991,  991,  991,  991,  991,  991,
  991,  991,  991,  991,  991,  991,  991,  991,  991,  991,
  991,  991,  991, -237,  991,  932,    0,    0,  -90,    0,
  991,    0,    0,  941,    0,  737,  837,  882,  -31,  679,
  -10,  -10,  -10,  -10,   60,   60,   60,   60,  -24,  -24,
  -24,   20,   20,    0,    0,    0,  -34,    0,  -67,    0,
   10,  -25,    0,    0,  991,    0,    0,  991,  991,    0,
    0,
};
private final static short rindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  494,    0,   96,    0,
    0,    0,    0,    0,    1,   28,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  440,  448,  777,  567,  729,
  542,  624,  640,  669,  376,  384,  488,  534,  192,  249,
  288,  123,  135,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,
};
private final static short gindex[] = {                                     41,
 1041,   68,    0,    0,    0,    0,    0,    0,  -26,    0,
   12,    0,   16,   -3,
};
private final static short table[] = {                                      32,
   33,   74,   68,   66,   67,   62,   46,   64,   68,   71,
   60,   58,   62,   59,   69,   61,   73,   60,   58,   72,
   59,    3,   61,  105,   34,  106,   62,   54,   51,   70,
   52,   60,   58,   31,   59,  109,   61,   33,   33,  101,
   16,   33,   33,   33,   33,   33,   33,   33,   31,   51,
  107,   52,   65,  108,   36,   75,   62,    0,   33,   33,
   33,   60,   33,   33,   54,   54,   61,    0,   54,   54,
   54,   54,   54,   54,   54,   98,   27,   28,   29,   30,
  102,    0,   37,    0,    0,   54,   54,   54,    0,   54,
   54,   33,    0,   33,   33,   25,   62,    0,    0,    0,
    0,   60,   58,   97,   59,   99,   61,    0,    0,    0,
    0,  103,    0,    0,  104,    0,    0,    0,   54,    0,
   54,   54,   19,    0,   33,   33,    0,    0,    0,    0,
    0,    0,   25,   25,   20,    0,   25,   25,   25,   25,
   25,    0,   25,    0,    0,  110,    0,    0,  104,  111,
    0,   54,   54,   25,   25,   25,    0,   25,   25,    0,
   19,    0,    0,   19,    0,   19,   19,   19,    3,    0,
    0,    0,   20,    0,    0,   20,    0,   20,   20,   20,
   19,   19,   19,    0,   19,   19,    0,    0,   25,   25,
    0,   16,   20,   20,   20,    0,   20,   20,    0,    3,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   19,   19,    0,    0,   25,
   25,    0,    0,    0,    0,    0,    0,   20,   20,   16,
    0,    0,   16,    0,    0,   16,   47,   48,   49,   50,
   53,   54,   55,   56,   57,    0,   19,   19,   17,   16,
   16,   16,    0,   16,   16,    0,    0,    0,   20,   20,
    0,   53,   54,   55,   56,   57,   33,   33,   33,   33,
   33,   33,   33,   33,   33,   33,   33,    0,    0,    0,
    0,    0,    0,    0,   16,   16,   17,   18,    0,   17,
    0,    0,   17,   54,   54,   54,   54,   54,   54,   54,
   54,   54,   54,   54,    0,    0,   17,   17,   17,    0,
   17,   17,    0,    0,    0,   16,   16,    0,    0,    0,
    0,    0,    0,    0,    0,   18,    0,    0,   18,    0,
    0,   18,    0,   55,   56,   57,    0,    0,    0,    0,
    0,   17,   17,    0,    0,   18,   18,   18,    0,   18,
   18,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   25,   25,   25,   25,   25,   25,   25,   25,   25,
   25,   25,   17,   17,    0,   12,    0,    0,    0,    0,
   18,   18,    0,   13,    0,    0,    0,    0,   19,   19,
   19,   19,   19,   19,   19,   19,   19,   19,   19,    0,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   18,   18,   12,    0,    0,   12,    0,    0,   12,
    0,   13,    0,    0,   13,    0,    0,   13,    0,    0,
    0,    0,    0,   12,   12,   12,    0,   12,   12,    3,
    0,   13,   13,   13,    0,   13,   13,    4,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   16,   16,   16,
   16,   16,   16,   16,   16,   16,   16,   16,   12,   12,
    0,    0,    0,    0,    0,    0,   13,   13,    0,    0,
    3,    0,    0,    3,    0,    0,    0,   14,    4,    0,
    0,    4,    0,    1,    0,    0,    0,    3,    3,   12,
   12,    0,    3,    0,    0,    4,    4,   13,   13,    0,
    4,    0,    0,    0,   17,   17,   17,   17,   17,   17,
   17,   17,   17,   17,   17,   14,    0,    0,   14,    0,
    0,   14,    3,   15,    1,    0,    0,    1,    0,    0,
    4,    8,    0,    0,    0,   14,   14,   14,    0,   14,
   14,    1,    1,   18,   18,   18,   18,   18,   18,   18,
   18,   18,   18,   18,    3,    0,    6,    0,    0,    0,
    0,   15,    4,    0,   15,    0,    0,   15,    0,    8,
   14,   14,    8,    0,    0,    8,    1,    0,    0,    0,
    0,   15,   15,   15,    0,   15,   15,    0,    0,    8,
    8,    0,    0,    0,    8,    0,    0,    6,    0,    0,
    6,   14,   14,    0,    0,    0,    0,    0,    1,    0,
    0,    0,    0,    9,    6,    6,   15,   15,    0,    6,
    0,    0,    0,    0,    8,    8,    0,    0,    0,   10,
    0,   12,   12,   12,   12,   12,   12,   12,   12,   13,
   13,   13,   13,   13,   13,   13,   13,   15,   15,    6,
    6,    9,    0,    0,    9,    8,    8,    9,   11,    0,
    0,    0,    0,    0,    0,    0,    0,   10,    0,    0,
   10,    9,    9,   10,    0,    0,    9,    0,    0,    0,
    6,    6,    0,    0,    0,    0,    0,   10,   10,    0,
    0,    0,   10,    0,    0,    3,   11,    0,    0,   11,
    0,    0,   11,    4,    4,   62,    9,    9,    0,    0,
   60,   58,    0,   59,    0,   61,   11,   11,    7,    0,
    0,   11,   10,   10,    0,    0,    0,    0,   51,    0,
   52,    0,    0,    0,    0,    0,    0,    9,    9,    0,
    0,    0,    0,   14,   14,   14,   14,   14,   14,   14,
   14,   11,   11,   10,   10,    0,    7,    0,    0,    7,
    0,    0,    7,   62,   46,    0,    5,    0,   60,   58,
    0,   59,    0,   61,    0,    0,    7,    7,    0,    0,
    0,    7,   11,   11,    0,    0,   51,    0,   52,   15,
   15,   15,   15,   15,   15,   15,   15,    8,    8,    8,
    8,    8,    8,    0,    0,    0,    0,    5,    0,    0,
    5,    7,    7,    0,    0,    0,    0,    0,    0,    0,
   45,    0,    6,    6,    5,    5,    0,    0,    0,    5,
   62,   46,    0,    0,    0,   60,   58,    0,   59,    0,
   61,    0,    7,    7,    0,    0,    0,    0,    0,    0,
   44,    0,    0,   51,    0,   52,   63,    0,    0,    5,
    0,    0,    0,   62,   46,    0,    0,    0,   60,   58,
    0,   59,    0,   61,    0,    0,    0,    0,    0,    9,
    9,    9,    9,    9,    9,    0,   51,   45,   52,    0,
    5,    5,    0,    0,    0,   10,   10,   10,   10,   10,
   10,    0,    0,    0,    0,    0,    0,    0,   62,   46,
    0,    0,    0,   60,   58,    0,   59,   44,   61,    0,
   45,    0,    0,    0,   11,   11,   11,   11,   11,   11,
    0,   51,    0,   52,    0,    0,   47,   48,   49,   50,
   53,   54,   55,   56,   57,   11,    0,    0,    0,    0,
   44,    0,   14,    0,   11,    9,   38,   10,    0,    0,
    0,   14,  100,   11,    9,   45,   10,    0,    0,    0,
   14,    0,    0,    9,    0,   10,    0,    0,    0,    0,
    0,    0,    0,    0,    7,    7,    0,    0,    0,    0,
    0,    0,    0,   43,   47,   48,   49,   50,   53,   54,
   55,   56,   57,   13,    0,    0,    0,    0,    0,    0,
    0,    0,   13,   11,    0,    0,    0,    0,    0,    0,
   14,   13,    0,    9,    0,   10,    0,    0,    0,    0,
    0,    0,    5,    5,    0,   15,    0,   37,   12,    0,
    0,    0,    0,    0,   15,    0,    0,   12,    0,    0,
    0,    0,    0,   15,    0,   73,   12,    0,    0,   42,
   43,   47,   48,   49,   50,   53,   54,   55,   56,   57,
    0,   13,   76,   77,   78,   79,   80,   81,   82,   83,
   84,   85,   86,   87,   88,   89,   90,   91,   92,   93,
   94,   95,   96,    0,   47,   48,   49,   50,   53,   54,
   55,   56,   57,   15,    0,    0,   12,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   47,
   48,   49,   50,   53,   54,   55,   56,   57,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,
    2,    3,    4,    0,    5,    6,    7,    8,    1,    2,
    3,    4,    0,    5,    6,    7,    8,    1,    2,    3,
    4,    0,    5,    6,    7,    8,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    1,    2,    3,
    4,    0,    5,    6,    7,    8,
};
private final static short check[] = {                                      59,
    0,   44,   93,   40,  263,   37,   38,   46,   93,   61,
   42,   43,   37,   45,   59,   47,  125,   42,   43,   41,
   45,  259,   47,   58,   13,   93,   37,    0,   60,   33,
   62,   42,   43,   93,   45,   61,   47,   37,   38,   66,
    0,   41,   42,   43,   44,   45,   46,   47,   93,   60,
   41,   62,   91,   44,   14,   40,   37,   -1,   58,   59,
   60,   42,   62,   63,   37,   38,   47,   -1,   41,   42,
   43,   44,   45,   46,   47,   64,    9,   10,   11,   12,
   69,   -1,  125,   -1,   -1,   58,   59,   60,   -1,   62,
   63,   91,   -1,   93,   94,    0,   37,   -1,   -1,   -1,
   -1,   42,   43,   63,   45,   65,   47,   -1,   -1,   -1,
   -1,   71,   -1,   -1,   74,   -1,   -1,   -1,   91,   -1,
   93,   94,    0,   -1,  124,  125,   -1,   -1,   -1,   -1,
   -1,   -1,   37,   38,    0,   -1,   41,   42,   43,   44,
   45,   -1,   47,   -1,   -1,  105,   -1,   -1,  108,  109,
   -1,  124,  125,   58,   59,   60,   -1,   62,   63,   -1,
   38,   -1,   -1,   41,   -1,   43,   44,   45,  259,   -1,
   -1,   -1,   38,   -1,   -1,   41,   -1,   43,   44,   45,
   58,   59,   60,   -1,   62,   63,   -1,   -1,   93,   94,
   -1,    0,   58,   59,   60,   -1,   62,   63,   -1,  259,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   93,   94,   -1,   -1,  124,
  125,   -1,   -1,   -1,   -1,   -1,   -1,   93,   94,   38,
   -1,   -1,   41,   -1,   -1,   44,  268,  269,  270,  271,
  272,  273,  274,  275,  276,   -1,  124,  125,    0,   58,
   59,   60,   -1,   62,   63,   -1,   -1,   -1,  124,  125,
   -1,  272,  273,  274,  275,  276,  266,  267,  268,  269,
  270,  271,  272,  273,  274,  275,  276,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   93,   94,   38,    0,   -1,   41,
   -1,   -1,   44,  266,  267,  268,  269,  270,  271,  272,
  273,  274,  275,  276,   -1,   -1,   58,   59,   60,   -1,
   62,   63,   -1,   -1,   -1,  124,  125,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   38,   -1,   -1,   41,   -1,
   -1,   44,   -1,  274,  275,  276,   -1,   -1,   -1,   -1,
   -1,   93,   94,   -1,   -1,   58,   59,   60,   -1,   62,
   63,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  266,  267,  268,  269,  270,  271,  272,  273,  274,
  275,  276,  124,  125,   -1,    0,   -1,   -1,   -1,   -1,
   93,   94,   -1,    0,   -1,   -1,   -1,   -1,  266,  267,
  268,  269,  270,  271,  272,  273,  274,  275,  276,   -1,
  266,  267,  268,  269,  270,  271,  272,  273,  274,  275,
  276,  124,  125,   38,   -1,   -1,   41,   -1,   -1,   44,
   -1,   38,   -1,   -1,   41,   -1,   -1,   44,   -1,   -1,
   -1,   -1,   -1,   58,   59,   60,   -1,   62,   63,    0,
   -1,   58,   59,   60,   -1,   62,   63,    0,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  266,  267,  268,
  269,  270,  271,  272,  273,  274,  275,  276,   93,   94,
   -1,   -1,   -1,   -1,   -1,   -1,   93,   94,   -1,   -1,
   41,   -1,   -1,   44,   -1,   -1,   -1,    0,   41,   -1,
   -1,   44,   -1,    0,   -1,   -1,   -1,   58,   59,  124,
  125,   -1,   63,   -1,   -1,   58,   59,  124,  125,   -1,
   63,   -1,   -1,   -1,  266,  267,  268,  269,  270,  271,
  272,  273,  274,  275,  276,   38,   -1,   -1,   41,   -1,
   -1,   44,   93,    0,   41,   -1,   -1,   44,   -1,   -1,
   93,    0,   -1,   -1,   -1,   58,   59,   60,   -1,   62,
   63,   58,   59,  266,  267,  268,  269,  270,  271,  272,
  273,  274,  275,  276,  125,   -1,    0,   -1,   -1,   -1,
   -1,   38,  125,   -1,   41,   -1,   -1,   44,   -1,   38,
   93,   94,   41,   -1,   -1,   44,   93,   -1,   -1,   -1,
   -1,   58,   59,   60,   -1,   62,   63,   -1,   -1,   58,
   59,   -1,   -1,   -1,   63,   -1,   -1,   41,   -1,   -1,
   44,  124,  125,   -1,   -1,   -1,   -1,   -1,  125,   -1,
   -1,   -1,   -1,    0,   58,   59,   93,   94,   -1,   63,
   -1,   -1,   -1,   -1,   93,   94,   -1,   -1,   -1,    0,
   -1,  266,  267,  268,  269,  270,  271,  272,  273,  266,
  267,  268,  269,  270,  271,  272,  273,  124,  125,   93,
   94,   38,   -1,   -1,   41,  124,  125,   44,    0,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   38,   -1,   -1,
   41,   58,   59,   44,   -1,   -1,   63,   -1,   -1,   -1,
  124,  125,   -1,   -1,   -1,   -1,   -1,   58,   59,   -1,
   -1,   -1,   63,   -1,   -1,  266,   38,   -1,   -1,   41,
   -1,   -1,   44,  266,  267,   37,   93,   94,   -1,   -1,
   42,   43,   -1,   45,   -1,   47,   58,   59,    0,   -1,
   -1,   63,   93,   94,   -1,   -1,   -1,   -1,   60,   -1,
   62,   -1,   -1,   -1,   -1,   -1,   -1,  124,  125,   -1,
   -1,   -1,   -1,  266,  267,  268,  269,  270,  271,  272,
  273,   93,   94,  124,  125,   -1,   38,   -1,   -1,   41,
   -1,   -1,   44,   37,   38,   -1,    0,   -1,   42,   43,
   -1,   45,   -1,   47,   -1,   -1,   58,   59,   -1,   -1,
   -1,   63,  124,  125,   -1,   -1,   60,   -1,   62,  266,
  267,  268,  269,  270,  271,  272,  273,  266,  267,  268,
  269,  270,  271,   -1,   -1,   -1,   -1,   41,   -1,   -1,
   44,   93,   94,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   94,   -1,  266,  267,   58,   59,   -1,   -1,   -1,   63,
   37,   38,   -1,   -1,   -1,   42,   43,   -1,   45,   -1,
   47,   -1,  124,  125,   -1,   -1,   -1,   -1,   -1,   -1,
  124,   -1,   -1,   60,   -1,   62,   63,   -1,   -1,   93,
   -1,   -1,   -1,   37,   38,   -1,   -1,   -1,   42,   43,
   -1,   45,   -1,   47,   -1,   -1,   -1,   -1,   -1,  266,
  267,  268,  269,  270,  271,   -1,   60,   94,   62,   -1,
  124,  125,   -1,   -1,   -1,  266,  267,  268,  269,  270,
  271,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   37,   38,
   -1,   -1,   -1,   42,   43,   -1,   45,  124,   47,   -1,
   94,   -1,   -1,   -1,  266,  267,  268,  269,  270,  271,
   -1,   60,   -1,   62,   -1,   -1,  268,  269,  270,  271,
  272,  273,  274,  275,  276,   33,   -1,   -1,   -1,   -1,
  124,   -1,   40,   -1,   33,   43,   44,   45,   -1,   -1,
   -1,   40,   41,   33,   43,   94,   45,   -1,   -1,   -1,
   40,   -1,   -1,   43,   -1,   45,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  266,  267,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  267,  268,  269,  270,  271,  272,  273,
  274,  275,  276,   91,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   91,   33,   -1,   -1,   -1,   -1,   -1,   -1,
   40,   91,   -1,   43,   -1,   45,   -1,   -1,   -1,   -1,
   -1,   -1,  266,  267,   -1,  123,   -1,  125,  126,   -1,
   -1,   -1,   -1,   -1,  123,   -1,   -1,  126,   -1,   -1,
   -1,   -1,   -1,  123,   -1,  125,  126,   -1,   -1,  266,
  267,  268,  269,  270,  271,  272,  273,  274,  275,  276,
   -1,   91,   42,   43,   44,   45,   46,   47,   48,   49,
   50,   51,   52,   53,   54,   55,   56,   57,   58,   59,
   60,   61,   62,   -1,  268,  269,  270,  271,  272,  273,
  274,  275,  276,  123,   -1,   -1,  126,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  268,
  269,  270,  271,  272,  273,  274,  275,  276,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,
  258,  259,  260,   -1,  262,  263,  264,  265,  257,  258,
  259,  260,   -1,  262,  263,  264,  265,  257,  258,  259,
  260,   -1,  262,  263,  264,  265,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,  258,  259,
  260,   -1,  262,  263,  264,  265,
};
private final static short FINAL_STATE = 16;
private final static String name[] = {
"end-of-file",null,null,null,null,null,null,null,null,null,null,null,null,null,
null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
null,null,null,"'!'",null,null,null,"'%'","'&'",null,"'('","')'","'*'","'+'",
"','","'-'","'.'","'/'",null,null,null,null,null,null,null,null,null,null,"':'",
"';'","'<'","'='","'>'","'?'",null,null,null,null,null,null,null,null,null,null,
null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
null,"'['",null,"']'","'^'",null,null,null,null,null,null,null,null,null,null,
null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
null,null,"'{'","'|'","'}'","'~'",null,null,null,null,null,null,null,null,null,
null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
null,null,null,null,null,null,null,null,null,"ERROR","FALSE","IDENTIFIER",
"INTEGER","LEX_ERROR","REAL","STRING","TRUE","UNDEFINED","OP_LOR","OP_LAND",
"OP_EQ","OP_NE","OP_IS","OP_ISNT","OP_LE","OP_GE","OP_SHL","OP_SHR","OP_SHRR",
"UNARY",
};
private final static String rule[] = {
"$accept : Expression",
"Expression : Expr",
"Expression : Expr '?' Expression ':' Expression",
"Expr : Expr OP_LOR Expr",
"Expr : Expr OP_LAND Expr",
"Expr : Expr '|' Expr",
"Expr : Expr '^' Expr",
"Expr : Expr '&' Expr",
"Expr : Expr OP_EQ Expr",
"Expr : Expr OP_NE Expr",
"Expr : Expr OP_IS Expr",
"Expr : Expr OP_ISNT Expr",
"Expr : Expr '<' Expr",
"Expr : Expr '>' Expr",
"Expr : Expr OP_LE Expr",
"Expr : Expr OP_GE Expr",
"Expr : Expr OP_SHL Expr",
"Expr : Expr OP_SHR Expr",
"Expr : Expr OP_SHRR Expr",
"Expr : Expr '+' Expr",
"Expr : Expr '-' Expr",
"Expr : Expr '*' Expr",
"Expr : Expr '/' Expr",
"Expr : Expr '%' Expr",
"Expr : PrefixExpr",
"PrefixExpr : SuffixExpr",
"PrefixExpr : '+' PrefixExpr",
"PrefixExpr : '-' PrefixExpr",
"PrefixExpr : '!' PrefixExpr",
"PrefixExpr : '~' PrefixExpr",
"SuffixExpr : Atom",
"SuffixExpr : SuffixExpr '.' Identifier",
"SuffixExpr : SuffixExpr '[' Expression ']'",
"Atom : Identifier",
"Atom : Literal",
"Atom : List",
"Atom : Record",
"Atom : Call",
"Atom : '(' Expression ')'",
"List : '{' ListBody ListEnd",
"List : '{' ListEnd",
"ListEnd : '}'",
"ListEnd : ',' '}'",
"ListBody : Expression",
"ListBody : ListBody ',' Expression",
"Record : '[' DefinitionList RecordEnd",
"Record : '[' RecordEnd",
"RecordEnd : ']'",
"RecordEnd : ';' ']'",
"DefinitionList : Identifier '=' Expression",
"DefinitionList : DefinitionList ';' Identifier '=' Expression",
"Call : Identifier '(' ListBody ')'",
"Call : Identifier '(' ')'",
"Literal : REAL",
"Literal : Strings",
"Literal : INTEGER",
"Literal : TRUE",
"Literal : FALSE",
"Literal : UNDEFINED",
"Literal : ERROR",
"Strings : STRING",
"Strings : Strings STRING",
"Identifier : IDENTIFIER",
};
private final static String ntname[] = {
    "Expression",
    "Expr",
    "PrefixExpr",
    "SuffixExpr",
    "Atom",
    "Literal",
    "Call",
    "Record",
    "List",
    "ListBody",
    "DefinitionList",
    "Identifier",
    "Strings",
    "ListEnd",
    "RecordEnd"
};
/** Set to true if parsing actions should be traced. */
/*package*/ boolean tracing = false;

/** If true, accept when a prefix of the input matches. */
/*package*/ boolean acceptPrefix = false;

/** Flag used in error recovery.
 * Number of tokens that must be successfully scanned before leaving
 * error-recovery mode.
 */
private int errorLookahead;

/** Last token read by lex.  The special value -1 means there is no
 * current lookahead.
 */
private int lookahead = -1;

/** The current LALR parser state.
 *  Invariant:  state == stateStack[stackTop]
 */
private int state;

/** Fixed maximum size for the parse and value stacks (currently 500).
 * This should be more than enough unless the grammar uses right-recursive
 * rules to parse a very long list, for example
 * <pre>
 *       list : element | element ',' list ;
 * </pre>
 * on input
 * <pre>
 *       a, a, a, a, ... [500 elements in all]
 * </pre>
 * If the stack overflows, an ArrayIndexOutOfBoundsException will be thrown.
 */
private final static int STACKSIZE = 500;

/** Stack of parser states.
 *  Invariant:  state == stateStack[stackTop]
 */
private int stateStack[] = new int[STACKSIZE];

/** Stack of semantic values, parallel to stateStack */
private Object valStack[] = new Object[STACKSIZE];

/** Index in stateStack of the top (highest-numbered) element of the stack. */
private int stackTop = -1;

/** The semantic value associated with the LHS of the last production */
private Object val;

/** The semantic value associated with the last token returned by lex() */
private Object lval;

/** Print a message to System.out if tracing is true.
 * @param msg the message to print.
 */
private void trace(Object msg) {
    if (tracing) {
        System.out.println(msg);
    }
} // trace(Object)

/** Convert the current stack into a string (top of stack at right).
 * @return string version of current stack.
 */
private String showStack() {
    if (stackTop < 0) {
        return "EMPTY";
    }
    StringBuffer sb = new StringBuffer(Integer.toString(stateStack[0]));
    for (int i = 1; i <= stackTop; i++) {
        sb.append(" " + stateStack[i]);
    }
    return sb.toString();
} // showStack()

/** Translate a token number to a name.
 * @param token the code for a token.
 * @return the name of the token.
 */
private String tokenName(int token) {
    if (token == ERROR_TOKEN) {
        return "$error$";
    }
    if (token < 0 || token >= name.length) {
        return "<unknown_token>";
    }
    if (name[token] != null) {
        return name[token];
    }
    if (token > 32 && token < 127) {
        return "'" + (char)token + "'";
    }
    return "<unknown_token>";
} // tokenName(int)

/** Generate a list of all tokens that can be accepted in the current state.
 * This method is only used for printing error messages, so it doesn't have
 * to be particularly fast.
 * @return an array of token codes.
 */
private int[] validTokens(int state) {
    // Count how many there are.
    int count = 0;
    for (int token = 0; token <= name.length; token++) {
        if (token == ERROR_TOKEN) {
            continue;
        }
        if (tableLookup(sindex, state, token) >= 0
            || tableLookup(rindex, state, token) >= 0)
        {
            count++;
        }
    }

    // Gather the results.
    int[] result = new int[count];
    int i = 0;
    for (int token = 0; token <= name.length; token++) {
        if (token == ERROR_TOKEN) {
            continue;
        }
        if (tableLookup(sindex, state, token) >= 0
            || tableLookup(rindex, state, token) >= 0)
        {
            result[i++] = token;
        }
    }
    return result;
} // validTokens(int)

/** Look up a value in a compressed version of a two-dimentsional array
 * of positive integers.
 * The two-dimensional tables generated by byacc are compressed by packing
 * them in to a pair of parallel long arrays check[] and table[].
 * The virtual array V[x,y] is represented by mapping rows to contiguous
 * slices of table[] as indicated by the array start[].  Each row of
 * V[,] starts at offset start[row] in table[].  Thus the value
 * V[row,column] is stored in table[start[row] + column].  However,
 * the array V is sparse, and slots corresponding to "missing" elements of
 * V[,] may be used by other rows (or even other arrays).  The element
 * table[start[row] + column] actually contains V[row,column] if and
 * only if the corresponding element of check[] contains column:
 *   table[start[row] + column] == column.
 * A row of V that is entirely missing is represented by start[row]==0.
 * @param start a mapping from rows of V to offsets within table[] and
 * check[].
 * @param row the desired row of V.
 * @param column the resired column of V.
 * @return the value of V[row,column] if that element exists.  Otherwise,
 * return -1.
 */
private static final int tableLookup(short[] start, int row, int column) {
    int offset = start[row];
    if (offset == 0) {
        return -1;
    }
    offset += column;
    if (offset < 0) {
        return -1;
    }
    if (offset >= check.length) {
        return -1;
    }
    if (check[offset] != column) {
        return -1;
    }
    return table[offset];
} // tableLookup(short[],int,int)

/** Check whether the the unconsumed input is a syntactically valid phrase
 * according to the grammar.
 * Parsing stops at the end of the input, or the first token that cannot
 * be included in a prefix of a valid 
 * phrase according to the grammar.  If "acceptPrefix" is false and an
 * invalid token is encountered before the end of the input, an error occurs.
 * An error is also signaled if "acceptPrefix" is true but the input preceding
 * the invalid token is not a valid phrase according the the grammar.
 * <p>
 * If the input is already at end of file when this method is called, it
 * silently returns null.
 * If an error occurs, a message is printed by calling the user-supplied
 * method error(String) and the result is null.   On success, the return value
 * is the "semantic value" assigned by semantic routines to the start symbol.
 *
 * @param acceptPrefix if true, the input does not to be completely consumed.
 * @return the "semantic value" corresponding to the phrase found or null for
 * errors or end-of-file.
 */
public Object parse(boolean acceptPrefix) {
    this.acceptPrefix = acceptPrefix;
    errorLookahead = 0;
    stackTop = 0;
    state = 0;
    stateStack[stackTop] = 0;

    //outer loop: until parsing is done, either correctly, or w/error
    for (;;) {
        int prod; // set by the inner loop to the number of a production
        int nextState;

        // inner loop: figure out whether to shift or reduce
        for (;;) {
            // First check whether this is a "default-reduce" state (i.e.,
            // whether this state has only one action, which is to reduce by a
            // particular production).  If so, we don't even look at the next
            // token.
            prod = defred[state];
            if (prod != 0) {
                if (tracing) {
                    trace("Stack " + showStack()
                                + " default action is reduce by " + prod);
                }
                break;
            }

            // Get a lookahead token
            if (lookahead < 0) {
                lookahead = lex();
            }
            if (state == 0 && lookahead == 0) {
                // Nothing left to parse; just return null
                if (tracing) {
                    trace("Null input");
                }
                return null;
            }
            if (tracing) {
                trace("Stack " + showStack()
                            + " token " + lookahead
                            + " (" + tokenName(lookahead) + ")");
            }

            // Check for a shift action on this token
            nextState = tableLookup(sindex, state, lookahead);
            if (nextState >= 0) {
                state = nextState;
                stateStack[++stackTop] = state;
                valStack[stackTop] = lval;
                lookahead = -1;
                if (tracing) {
                    trace("shift to stack " + showStack());
                }
                // If we are recovering from an error, decrement the number of
                // tokens that have to be consumed before leaving recovery
                // status.
                if (errorLookahead > 0) {
                    --errorLookahead;
                }
                prod = -1;
                break;
            }

            // Check for a reduce action on this token
            prod = tableLookup(rindex, state, lookahead);
            if (prod > 0) {
                break;
            }

            // This point is only reached on an error (no shift or reduce
            // action for this state and lookahead).

            if (acceptPrefix) {
                // See if what we've seen so far would be accepted if the
                // lookhead were EOF.
                for (;;) {
                    if (tracing)
                        trace("Stack " + showStack()
                            + ": pretend lookhead EOF");
                    prod = defred[state];
                    if (prod != 0) {
                        if (tracing) {
                            trace("Default action is reduce by " + prod);
                        }
                    } else {
                        prod = tableLookup(rindex, state, 0);
                        if (tracing) {
                            trace("Reduce by " + prod + " at EOF");
                        }
                    }
                    if (prod <= 0) {
                        break;
                    }
                    reduceBy(prod);
                }
            }
            if (state == FINAL_STATE && (acceptPrefix || lookahead == 0)) {
                if (tracing) {
                    trace("Prefix matches");
                }
                // At this point, the input scanned thus far is a maximal
                // match for the start symbol of the grammar -- that is,
                // no more tokens can be consumed.  We return an indication
                // of success, and the caller can determine whether there
                // is more to consume by testing for nextToken() == 0.
                return val;
            }

            // ************ Error Recovery *********************
            if (errorLookahead==0)
            {
                // suppress this message if we are already in error-recovery
                // mode
                error("syntax error");
            }
            if (errorLookahead < 3) {
                // Pop states util we find one that can accept the "error"
                // token
                errorLookahead = 3;
                for (;;) {
                    if (stackTop<0) {
                        if (tracing) {
                            trace("Recovery deletes all left context");
                        }
                        return null;
                    }
                    nextState = tableLookup(sindex,
                                  stateStack[stackTop], ERROR_TOKEN);
                    if (nextState >= 0) {
                        if (tracing) {
                            trace("Stack " + showStack()
                                + ", error recovery shifting to state "
                                + nextState);
                        }
                        state = nextState;
                        stateStack[++stackTop] = state;
                        valStack[stackTop] = lval;
                        prod = -1;
                        break;
                    }
                    if (tracing) {
                        trace("error recovery discarding state "
                            + stateStack[stackTop]);
                    }
                    if (stackTop<0) {
                        if (tracing) {
                            trace("Recovery deletes all left context");
                        }
                        return null;
                    }
                    stackTop--;
                }
            } else { // errorLookahead == 3
                if (lookahead == 0) {
                    // Cannot recover
                    trace("Recovery hits EOF");
                    return null;
                }
                if (tracing) {
                    trace("Stack " + showStack()
                        + ", error recovery discards token " + lookahead
                        + "(" + tokenName(lookahead) + ")");
                }
                lookahead = -1;  //read another
            }
            // ************ End of Error Recovery *********************
        } // inner loop
        if (prod > 0) {
            // perform a reduction
            reduceBy(prod);
            if (state == FINAL_STATE) {
                if (lookahead < 0) {
                    lookahead = lex();
                }
            }
        }
    } // main loop
} // parse(boolean)

/** Check whether the the unconsumed input is a syntactically valid phrase
 * according to the grammar.
 * This method is equivalent to parse(true).
 * @return the "semantic value" corresponding to the phrase found or null for
 * errors or end-of-file.
 */
public Object parse() {
    return parse(true);
} // parse()

/** Turn debug tracing on or off.
 * Debugging output goes to System.out.
 * @param on if true, turn tracing on; otherwise turn it off.
 * @return the previous value.
 */
public boolean enableTracing(boolean on) {
    boolean result = tracing;
    tracing = on;
    return result;
} // enableTracing(boolean)

/** Perform the syntactic and semantic actions associated with a "reduction"
 * step.
 * @param prod the production to be used.
 */
private void reduceBy(int prod) {
    // Perform the semantic action associated with prod
    if (tracing) {
        trace("reduce by production " + prod
            + " [" + rule[prod] + "]");
    }
    int rhsLength = len[prod];

    // The default action is $$ = $1
    val = valStack[stackTop - rhsLength + 1];

    switch(prod) {
        //########## USER-SUPPLIED ACTIONS ##########
case 2:
//line 65 "classad.y"
{ val = new CondExpr(((Expr)valStack[stackTop - 4]), ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 3:
//line 68 "classad.y"
{ val = new Op(Expr.OR, ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 4:
//line 69 "classad.y"
{ val = new Op(Expr.AND, ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 5:
//line 70 "classad.y"
{ val = new Op(Expr.BITOR, ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 6:
//line 71 "classad.y"
{ val = new Op(Expr.BITXOR, ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 7:
//line 72 "classad.y"
{ val = new Op(Expr.BITAND, ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 8:
//line 73 "classad.y"
{ val = new Op(Expr.EQUAL, ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 9:
//line 74 "classad.y"
{ val = new Op(Expr.NOT_EQUAL, ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 10:
//line 75 "classad.y"
{ val = new Op(Expr.SAME, ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 11:
//line 76 "classad.y"
{ val = new Op(Expr.DIFFERENT, ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 12:
//line 77 "classad.y"
{ val = new Op(Expr.LESS, ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 13:
//line 78 "classad.y"
{ val = new Op(Expr.GREATER, ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 14:
//line 79 "classad.y"
{ val = new Op(Expr.LESS_EQ, ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 15:
//line 80 "classad.y"
{ val = new Op(Expr.GREATER_EQ, ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 16:
//line 81 "classad.y"
{ val = new Op(Expr.LEFT_SHIFT, ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 17:
//line 82 "classad.y"
{ val = new Op(Expr.RIGHT_SHIFT, ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 18:
//line 83 "classad.y"
{ val = new Op(Expr.URIGHT_SHIFT, ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 19:
//line 84 "classad.y"
{ val = new Op(Expr.PLUS, ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 20:
//line 85 "classad.y"
{ val = new Op(Expr.MINUS, ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 21:
//line 86 "classad.y"
{ val = new Op(Expr.TIMES, ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 22:
//line 87 "classad.y"
{ val = new Op(Expr.DIV, ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 23:
//line 88 "classad.y"
{ val = new Op(Expr.MOD, ((Expr)valStack[stackTop - 2]), ((Expr)valStack[stackTop - 0])); }
break;
case 26:
//line 93 "classad.y"
{ val = new Op(Expr.UPLUS, ((Expr)valStack[stackTop - 0])); }
break;
case 27:
//line 94 "classad.y"
{ val = new Op(Expr.UMINUS, ((Expr)valStack[stackTop - 0])); }
break;
case 28:
//line 95 "classad.y"
{ val = new Op(Expr.NOT, ((Expr)valStack[stackTop - 0])); }
break;
case 29:
//line 96 "classad.y"
{ val = new Op(Expr.BIT_COMPLEMENT, ((Expr)valStack[stackTop - 0])); }
break;
case 31:
//line 100 "classad.y"
{ val = new SelectExpr(((Expr)valStack[stackTop - 2]),  ((AttrName)valStack[stackTop - 0])); }
break;
case 32:
//line 101 "classad.y"
{ val = new SubscriptExpr(((Expr)valStack[stackTop - 3]), ((Expr)valStack[stackTop - 1])); }
break;
case 33:
//line 104 "classad.y"
{ val = new AttrRef(((AttrName)valStack[stackTop - 0])); }
break;
case 35:
//line 106 "classad.y"
{ val = ((ListExpr)valStack[stackTop - 0]); }
break;
case 36:
//line 107 "classad.y"
{ val = ((RecordExpr)valStack[stackTop - 0]); }
break;
case 37:
//line 108 "classad.y"
{ val = ((Expr)valStack[stackTop - 0]); }
break;
case 38:
//line 109 "classad.y"
{ val = ((Expr)valStack[stackTop - 1]); }
break;
case 39:
//line 112 "classad.y"
{ val = new ListExpr(((List)valStack[stackTop - 1])); }
break;
case 40:
//line 113 "classad.y"
{ val = new ListExpr(null); }
break;
case 43:
//line 120 "classad.y"
{ List l = new ArrayList(); l.add(((Expr)valStack[stackTop - 0])); val = l; }
break;
case 44:
//line 121 "classad.y"
{ List l = ((List)valStack[stackTop - 2]); l.add(((Expr)valStack[stackTop - 0])); val = l; }
break;
case 45:
//line 124 "classad.y"
{
        List l = ((List)valStack[stackTop - 1]);
        RecordExpr r = new RecordExpr(l.size());
        for (Iterator i = l.iterator(); i.hasNext(); ) {
            AttrName n = (AttrName) i.next();
            if (n.equals(AttrName.PARENT)) {
                error("Attribute name \"parent\" is reserved", false);
                i.next();
                continue;
            }
            Expr e = (Expr) i.next();
            if (r.lookup(n) != null) {
                error("Duplicate definition of attribute " + n + " in Record",
                    false);
            } else {
                r.insertAttribute(n, e);
            } /* if */
        } /* for */
        val = r;
    }
break;
case 46:
//line 144 "classad.y"
{ val = new RecordExpr(); }
break;
case 49:
//line 151 "classad.y"
{
        List l = new ArrayList();
        l.add(((AttrName)valStack[stackTop - 2]));
        l.add(((Expr)valStack[stackTop - 0]));
        val = l;
    }
break;
case 50:
//line 157 "classad.y"
{
        List l = ((List)valStack[stackTop - 4]);
        l.add(((AttrName)valStack[stackTop - 2]));
        l.add(((Expr)valStack[stackTop - 0]));
        val = l;
    }
break;
case 51:
//line 165 "classad.y"
{ val = FuncCall.getInstance(((AttrName)valStack[stackTop - 3]), ((List)valStack[stackTop - 1])); }
break;
case 52:
//line 166 "classad.y"
{ val = FuncCall.getInstance(((AttrName)valStack[stackTop - 2]), new ArrayList()); }
break;
case 53:
//line 169 "classad.y"
{ val = ((Constant)valStack[stackTop - 0]); }
break;
case 54:
//line 170 "classad.y"
{ val = ((Constant)valStack[stackTop - 0]); }
break;
case 55:
//line 171 "classad.y"
{ val = ((Constant)valStack[stackTop - 0]); }
break;
case 56:
//line 172 "classad.y"
{ val = Constant.TRUE; }
break;
case 57:
//line 173 "classad.y"
{ val = Constant.FALSE; }
break;
case 58:
//line 174 "classad.y"
{ val = Constant.Undef; }
break;
case 59:
//line 175 "classad.y"
{ val = Constant.Error; }
break;
case 61:
//line 179 "classad.y"
{
        val = Constant.getInstance(((Constant)valStack[stackTop - 1]).stringValue() + ((Constant)valStack[stackTop - 0]).stringValue());
    }
break;
//line 1121 "Parser.java"
        //########## END OF USER-SUPPLIED ACTIONS ##########
    }//switch

    if (tracing) {
        trace("Pop " + rhsLength
            + " state" + (rhsLength==1 ? "" : "s")
            + " from stack " + showStack());
    }
    stackTop -= rhsLength;
    state = stateStack[stackTop];
    int target = lhs[prod];

    // Check for special reduction <start> : <empty> in state 0
    if (state == 0 && rhsLength == 0) {
        trace("Special EOF case: shifting state " + FINAL_STATE);
        //explicitly say we're done
        state = FINAL_STATE;
    } else {
        // Consult goto tables (sort of like a shift action)
        int nextState = tableLookup(gindex, target, state);
        if (nextState >= 0) {
            // nextState = goto[LHS, state]
            if (tracing) {
                trace("Goto(" + showStack()
                    + "," + ntname[target]
                    + ") = " + nextState);
            }
            state = nextState;
        } else {
            // default goto: nextState = dgoto[LHS]
            if (tracing) {
                trace("DefaultGoto(" + ntname[target]
                    + ") = " + dgoto[target]);
            }
            state = dgoto[target];
        }
    }
    stateStack[++stackTop] = state;
    valStack[stackTop] = val;
} // reduceBy(int,int)

//line 187 "classad.y"
private static String VERSION = "$Id: Parser.java,v 1.8 2005/05/06 20:54:07 solomon Exp $";

/** Verbosity for error messages.
 * Values are:
 * 0 - no messages
 * 1 - only show message and line number
 * 2 - also echo line in question
 * 3 - also list tokens expected
 */
/*package*/ int verbosity = 3;

/** Place to send error messages.  Default is System.err. */
/*package*/ PrintStream errs = System.err;

/** Create a parser for parsing input from a Reader.
 * @param rdr the source of the input characters.
 */
public Parser(Reader rdr) {
    reader = new LineNumberReader(rdr);
} // Parser(Reader)

/** Create a parser for parsing input from an InputStream.
 * @param str the source of the input characters.
 */
public Parser(InputStream str) {
    reader = new LineNumberReader(new InputStreamReader(str));
} // Parser(InputStream)

/** Create a parser for parsing a String.
 * @param str the source of the input characters.
 */
public Parser(String str) {
    reader = new LineNumberReader(new StringReader(str));
} // Parser(String)

/** Supply a new source of input to this Parser.
 * @param rdr the new source of input.
 */
public void reset(Reader rdr) {
    reader = new LineNumberReader(rdr);
    lookahead = -1;
} // reset(Reader)

/** Supply a new source of input to this Parser.
 * @param str the new source of input.
 */
public void reset(InputStream str) {
    reader = new LineNumberReader(new InputStreamReader(str));
    lookahead = -1;
} // reset(InputStream)

/** Supply a new source of input to this Parser.
 * @param str the new source of input.
 */
public void reset(String str) {
    reader = new LineNumberReader(new StringReader(str));
    lookahead = -1;
} // reset(String)

/** Returns the current input line.
 * @return the current line number.
 */
public int curLine() {
    if (reader == null) {
        return 0;
    }
    return reader.getLineNumber();
} // curLine()

/** Returns the current input column.
 * @return the current line number.
 */
public int curColumn() {
    return tokenStart + 1;
} // curColumn()

// Lex support

/** Stream from which lex reads input.  */
private LineNumberReader reader;

/** The current input line. */
private String lineStr;

/** A version of lineStr unpacked into an array for speedy access */
private char[] line = new char[100];

/** The number of characters in the current input line. */
private int lineLen;

/** The current position in the current input line (0 = start of line) */
private int pos;

/** The position in the current line where the current token started. */
private int tokenStart;

/** The next input character to be consumed.  */
private int curChar;

/** A table of reserved words. */
private static final String[] reserved = {
    null,
    "error",
    "false",
    "is",
    "isnt",
    "true",
    "undefined",
};

/** A table of token codes parallel to the array reserved. */
private static final int[] reservedCode = {
    0, // unused
    ERROR,
    FALSE,
    OP_IS,
    OP_ISNT,
    TRUE,
    UNDEFINED
};

/** A trie constructed from the reserved words.
 * Three parallel arrays.  The element match[j] is supposed to match the
 * next letter of the input string.  If accept[j] = n != 0, then the string
 * matched thus far is reserved word n.  If the match[j] does not match
 * the next input character and alt[j] = n != 0, try match[n] instead.
 * If the input string starts with letter c, then start matching at position
 * trieStart[c], provided trieStart[c] > 0.
 * <p>
 * Why not simply use a HashMap, you ask?  Because that would require
 * allocating a new String object for each identifier in the input, just to see
 * if it is a reserved word.  With this setup, we can quickly check whether
 * a region in the array "char line[]" is a reserved word without any
 * storage allocation or garbage collection.  As a bonus, we also get
 * case-independent maching.
 */
private static char[] match;
private static int[] accept;
private static int[] alt;
private static int[] trieStart;
static {
    // Inidialize the trie data structure
    int len = 1;
    for (int i = 1; i < reserved.length; i++) {
        len += reserved[i].length() + 1;
    }
    trieStart = new int['z' + 1];
    match = new char[len];
    alt = new int[len];
    accept = new int[len];
    Arrays.fill(match, ' ');

    int next = 1;
    for (int i = 1; i < reserved.length; i++) {
        next = trieAdd(i, next);
    }
}; // static

/** A "wired-in" version of Character.toLowerCase(c) to avoid the
 * overhead in the common case of ASCII (c < 128).
 * 'A' -> 'a', 'a' -> 'a', '0' -> '0', '_' -> '_', and all other characters map
 * to zero.
 * <br>
 * Note: this table is only used for recognizing reserved words, which contain
 * only letters (no digits, underscores, etc.)  However, it maps digits and
 * underscores to themselves be cause the end of a reserved_word candidate is
 * recognized by a character c such that tolower[c] == 0.  Thus, for example,
 * "is_empty" is recognized as a non-reserved identifier because the underscore
 * is part of the word (tolower['_'] == '_') but the prefix "is_" fails the
 * trie-match algorithm.  See reservedLookup().
 */
private static final int[] tolower = new int[] {
       0,   0,   0,   0,   0,   0,   0,   0, /*   0 */
       0,   0,   0,   0,   0,   0,   0,   0, /*   8 */
       0,   0,   0,   0,   0,   0,   0,   0, /*  16 */
       0,   0,   0,   0,   0,   0,   0,   0, /*  24 */
       0,   0,   0,   0,   0,   0,   0,   0, /*  32 */
       0,   0,   0,   0,   0,   0,   0,   0, /*  40 */
      48,  49,  50,  51,  52,  53,  54,  55, /*  48 */
      56,  57,   0,   0,   0,   0,   0,   0, /*  56 */
       0,  97,  98,  99, 100, 101, 102, 103, /*  64 */
     104, 105, 106, 107, 108, 109, 110, 111, /*  72 */
     112, 113, 114, 115, 116, 117, 118, 119, /*  80 */
     120, 121, 122,   0,   0,   0,   0,  95, /*  88 */
       0,  97,  98,  99, 100, 101, 102, 103, /*  96 */
     104, 105, 106, 107, 108, 109, 110, 111, /* 104 */
     112, 113, 114, 115, 116, 117, 118, 119, /* 112 */
     120, 121, 122,   0,   0,   0,   0,   0  /* 120 */
};

/** Prints a message indicating that some particular event occurred at a given
 * point in the input.
 * @param msg the message.
 */
private void lexdebug(Object msg) {
    System.out.println("LEX: line " + reader.getLineNumber()
        + " column " + (tokenStart+1)
        + " " + msg);
} // lexdebug(Object)

    /** Helps to build the trie by adding reserved[n].
     * @param n the reserved-word code (index into reserved[]).
     * @param next the next free slot in parallel arrays (match,alt,accept).
     * @return the first slot in the parallel arrays not used by this
     * procedure.
     */
    private static int trieAdd(int n, int next) {
        String s = reserved[n];
        int pos;
        char c = s.charAt(0);
        if (trieStart[c] == 0) {
            trieStart[c] = next;
            trieStart[Character.toUpperCase(c)] = next;
            pos = next;
        } else {
            pos = trieStart[c];
        }
        for (int i = 0; i < s.length(); i++) {
            c = s.charAt(i);
            if (match[pos] == ' ') {
                match[pos++] = c;
            } else if (match[pos] == c) {
                pos++;
            } else {
                alt[pos] = next;
                pos = next;
                match[pos++] = c;
            }
        }
        accept[pos++] = n;
        if (pos > next) {
            next = pos;
        }
        return next;
    } // trieAdd(int,int)

/** Tests whether a character is "whitespace".
 * As of Java 1.4, there appear to be several incompatible notions of
 * "whitespace":
 * <ul>
 * <li>According to the Java Language Specification (Second Edition), Sections
 *     3.4 and 3.6, whitespace includes only the ASCII SPACE character (32),
 *     as well as Horizontal Tab (9), Linefeed (10), Formfeed (12),
 *     and Carriage Return (13) [all code points listed here are in decimal].
 * <li>The method Character.isSpace accepts the same set of characters.
 *     It is, however, deprecated.  The documentation says to use isWhitespace
 *     instead.
 * <li>The regular expression escape \s in java.util.regex matches all
 *     character satisfying Character.isSpace, plus the character Vertical Tab
 *     (11).
 * <li>Character.isWhitespace adds to this set the ASCII characters Field
 *     Separator (28), Group Separator (29), Record Separator (30), and Unit
 *     Separator (31), as well as several Unicode characters with values
 *     greater than 256.
 * </ul>
 * The classad language specification currently uses the same definition as
 * \s:  codes 9-13 and 32 (decimal).
 *
 * @param c a character code.
 * @return true if c is a character in the range 9-13 or 32 (decimal).
 */
private static final boolean isSpace(char c) {
    return c == 32 || (c >= 9 && c <= 13);
} // isSpace(char)

/** Get the "lookahead" token: the first token not yet consumed by the
 * parser.
 * The token is not removed from the input stream.
 * @return the code for the next token.
 * @see #getNextToken()
 */
public int nextToken() {
    if (lookahead < 0) {
        lookahead = lex();
    }
    return lookahead;
} // nextToken()

/** Get the value associated with the "lookahead" token: the first token not
 * yet consumed by the parser.
 * The token is not removed from the input stream.
 * @return the value associated with the next token.
 * @see #nextToken()
 */
public Object nextValue() {
    if (lookahead < 0) {
        lookahead = lex();
    }
    return lval;
} // nextValue()

/** Get and remove the "lookahead" token: the first token not yet consumed
 * by the parser.
 * The token is removed from the input stream.
 * @return the code for the next token.
 * @see #getNextToken()
 */
public int getNextToken() {
    if (lookahead < 0) {
        lookahead = lex();
    }
    int result = lookahead;
    lookahead = -1;
    return result;
} // getNextToken()

/** Gets the next line from reader and unpacks it to the array line[].
 * @return -1 for errors, 0 for EOF, or 1 for success.
 */
private final int getLine() {
    try {
        lineStr = reader.readLine();
    } catch (IOException e) {
        e.printStackTrace();
        return -1;
    }
    if (lineStr == null) {
        return 0; // EOF
    }

    lineLen = lineStr.length();
    
    if (line.length < lineLen + 1) {
        line = new char[lineLen + 20];
    }
    lineStr.getChars(0,lineLen,line,0);
    pos = 0;
    line[lineLen] = ' ';
    return 1;
} // getLine()

/** Check whether the word stored in the line[] array starting at position
 * tokenStart matches one of the reserved words.  If so, return its index
 * in the array reserved[].  Otherwise, return 0.
 * @return an index in reserved[] or 0.
 */
private final int reservedLookup() {
    // Find the starting point in the trie
    int c = line[tokenStart];
    if (c >= trieStart.length) {
        return 0;
    }
    int triePos = trieStart[c];
    if (triePos++ == 0) {
        return 0;
    }
    // Start matching with the second character of the input
    for (int i = tokenStart+1; ;i++) {
        c = line[i];
        if (c >= tolower.length || (c = tolower[c]) == 0) {
            // Next character is not a letter.  If accept[triePos] is non-zero,
            // what we've seen up to now is a reserved word.  Otherwise,
            // it is (part of) an identifier.  In either case, we just
            // return accept[triePos].
            return accept[triePos];
        }
        while (match[triePos] != c) {
            // Match failed.  See if there is an alternative match at this
            // point (sibling node in the trie).
            triePos = alt[triePos];
            if (triePos == 0) {
                // No alternative.  No match.
                return 0;
            }
        }
        // Successfully matched one more charcter of input.
        triePos++;
    }
} // reservedLookup()

/** The lexical scanner.
 * It finds the next token in the input stream and returns its token code.
 * It also sets the fields tokenStart and pos so that the text of the token
 * is in line[tokenStart ... pos-1]. (For efficiency reasons, we do not
 * return the text as a String, since that would entail allocation a new String
 * that would, in most cases, immediately become garbage.)  
 * The "semantics" associated with the current token (if any) is stored
 * in lval.
 * <p>
 * @return the token code for the next token; 0 for EOF; LEX_ERROR for error.
 */
private int lex() {
    int n;
    char quote;

    lval = null;
    // Skip spaces and comments
    for (;;) {
        if (pos == lineLen || (line[pos] == '/' && line[pos+1] == '/')) {
            if ((n = getLine()) <= 0) {
                return n;
            }
            continue;
        }
        if (line[pos] == '/' && line[pos+1] == '*') {
            for (pos += 2;;pos++) {
                if (pos >= lineLen) {
                    if ((n = getLine()) <= 0) {
                        return n;
                    }
                    pos = -1;
                    continue;
                }
                if (pos < lineLen - 1
                        && line[pos] == '*'
                        && line[pos+1] == '/')
                {
                    pos += 2;
                    break;
                }
            }
            continue;
        }
        if (!isSpace(line[pos])) {
            break;
        }
        pos++;
    }
    tokenStart = pos;

    // Identifier or reserved word
    if (Character.isJavaIdentifierStart(line[pos])) {
        do {
            pos++;
        } while (Character.isJavaIdentifierPart(line[pos]));
        int i = reservedLookup();
        if (i > 0) {
            if (tracing) {
                lexdebug("reserved word " + reservedCode[i]
                         + " (" + reserved[i] + ")");
            }
            return reservedCode[i];
        }
        lval = AttrName.fromString(
                    new String(line, tokenStart, pos - tokenStart));
        if (tracing) {
            lexdebug("ID(" + lval + ")");
        }
        return IDENTIFIER;
    }

    // Number or '.'
    if (Character.isDigit(line[pos]) || line[pos]=='.') {
        // Number or lone '.'
        int type;
        if (line[pos] == '.' && !Character.isDigit(line[pos+1])) {
            pos++;
            if (tracing) {
                lexdebug("DOT");
            }
            return '.';
        }
        // Accumulate leading digits
        for (; Character.isDigit(line[pos]); pos++) {
        }
        if (line[pos] == '.') {
            // There is a decimal point.  Grab the fraction part if any.
            type = REAL;
            for (pos++; Character.isDigit(line[pos]); pos++) {
            }
        } else {
            // There was no decimal point.  For now, assume it is an
            // integer.
            type = INTEGER;
            if (line[tokenStart] == '0'
                && (line[tokenStart+1] == 'x' || line[tokenStart+1] == 'x'))
            {
                // A hex integer constant.  Note that 'e' and 'E' are hex
                // digits, so 0x123e12 is parsed as a hex integer, and
                // and 0x123e+12 is parsed as three tokens: 0x123e + 12
                int value = 0;
                int digitValue;
                for (pos = tokenStart+2;
                    (digitValue = Character.digit(line[pos],16)) >= 0;
                    pos++)
                {
                    value = (value << 4) + digitValue;
                }
                // There must be at least one digit
                if (pos == tokenStart + 2) {
                    if (tracing) {
                        lexdebug("bad number");
                    }
                    lval = "hex constant with no digits("
                        + new String(line, tokenStart, pos - tokenStart)
                        + ")";
                    return LEX_ERROR;
                }
                lval = Constant.getInstance(value);
                if (tracing) {
                    lexdebug("INTEGER " + lval);
                }
                return INTEGER;
            }
        } // no decimal point
        // Now look for optional exponent part
        if (line[pos] == 'e' || line[pos] == 'E') {
            type = REAL;
            pos++;
            if (line[pos] == '+' || line[pos] == '-') {
                pos++;
            }
            if (!Character.isDigit(line[pos])) {
                // E[+-] must be followed by at least one digit
                if (tracing) {
                    lexdebug("bad float");
                }
                lval = "exponent with no digits("
                    + new String(line, tokenStart, pos - tokenStart)
                    + ")";
                return LEX_ERROR;
            }
            for (pos++; Character.isDigit(line[pos]); pos++) {
            }
        }
        // Finally, compute the value
        if (type == REAL) {
            lval = Constant.getInstance(
                        Double.parseDouble(
                            new String(line, tokenStart, pos - tokenStart)));
            if (tracing) {
                lexdebug("REAL " + lval);
            }
            return REAL;
        }
        // If there was no decimal point or exponent, we have to check
        // for a leading 0, meaning octal.
        int value = 0;
        int radix = (line[tokenStart] == '0') ? 8 : 10;
        for (int i=tokenStart; i<pos; i++) {
            int digitValue = Character.digit(line[i],radix);
            if (digitValue < 0) {
                if (tracing) {
                    lexdebug("bad oct");
                }
                lval = "octal constant with no octal digits("
                    + new String(line, tokenStart, pos - tokenStart)
                    + ")";
                return LEX_ERROR;
            }
            value = value * radix + digitValue;
        }
        lval = Constant.getInstance(value);
        if (tracing) {
            lexdebug("INT " + lval);
        }
        return INTEGER;
    } // Number

    // Multi-character operators
    switch (line[pos++]) {
    case '!':
        // != or !
        if (line[pos] == '=') {
            pos++;
            if (tracing) {
                lexdebug("NE");
            }
            return OP_NE;
        }
        break;
    case '&':
        // && or &
        if (line[pos] == '&') {
            pos++;
            if (tracing) {
                lexdebug("LAND");
            }
            return OP_LAND;
        }
        break;
    case '<':
        // << or <= or <
        if (line[pos] == '<') {
            pos++;
            if (tracing) {
                lexdebug("SHL");
            }
            return OP_SHL;
        }
        if (line[pos] == '=') {
            pos++;
            if (tracing) {
                lexdebug("LE");
            }
            return OP_LE;
        }
        break;
    case '=':
        // == or =
        if (line[pos] == '=') {
            pos++;
            if (tracing) {
                lexdebug("EQ");
            }
            return OP_EQ;
        }
        if (line[pos] == '?' && line[pos+1] == '=') {
            pos += 2;
            if (tracing) {
                lexdebug("IS");
            }
            return OP_IS;
        }
        if (line[pos] == '!' && line[pos+1] == '=') {
            pos += 2;
            if (tracing) {
                lexdebug("ISNT");
            }
            return OP_ISNT;
        }
        break;
    case '>':
        // >= or >> or >>> or >
        if (line[pos] == '=') {
            pos++;
            if (tracing) {
                lexdebug("GE");
            }
            return OP_GE;
        }
        if (line[pos] == '>') {
            pos++;
            if (line[pos] == '>') {
                pos++;
                if (tracing) {
                    lexdebug("SHRR");
                }
                return OP_SHRR;
            }
            if (tracing) {
                lexdebug("SHR");
            }
            return OP_SHR;
        }
        break;
    case '|':
        // || or |
        if (line[pos] == '|') {
            pos++;
            if (tracing) {
                lexdebug("LOR");
            }
            return OP_LOR;
        }
        break;
    case '"':
    case '\'':
        // String constant or quoted attribute name
        // Simply gather the characters up to an unescaped matching quote.
        // Other escape processing is done later.
        quote = line[pos - 1];
        for (;;) {
            if (pos == lineLen) {
                // Unterminated string constant or attribute name.
                lval = "unterminated "
                    + (quote == '"' ? "string " : "attribute name ")
                    + new String(line, tokenStart, pos - tokenStart);
                return LEX_ERROR;
            }
            if (line[pos] == '\\') {
                pos +=2 ;
                continue;
            }
            if (line[pos] == quote) {
                pos++;
                break;
            }
            pos++;
        }
        if (quote == '"') {
            int result = STRING;
            lval = Constant.getInstance(line, tokenStart + 1, pos - 1);
            if (lval == null) {
                lval = "invalid string "
                    + new String(line, tokenStart, pos - tokenStart);
                result = LEX_ERROR;
            }
            if (tracing) {
                lexdebug("STRING(" + lval + ")");
            }
            return result;
        } else {
            int result = IDENTIFIER;
            lval = AttrName.fromText(
                                new String(line, tokenStart, pos - tokenStart));
            if (lval == null) {
                lval = "invalid attribute name "
                    + new String(line, tokenStart, pos - tokenStart);
                result = LEX_ERROR;
            }
            if (tracing) {
                lexdebug("ID(" + lval + ")");
            }
            return result;
        }
    } // switch (line[pos++])
    // In all other cases, simply return the single character.  If it
    // isn't legit, the parser will catch it.
    if (tracing) {
        lexdebug("CHAR('" + line[pos-1] + "')");
    }
    return line[pos-1];
} // lex()

/** Print an error message, decorated with the current line and column number
 * and information about valid lookaheads.
 * @param msg the message to print.
 */
private void error(String msg) {
    error(msg, true);
} // error(String)

/** Print an error message, decorated with the current line and column number.
 * @param msg the message to print.
 * @param lookahead if true, indicate valid lookaheads.
 */
private void error(String msg, boolean lookaheads) {
    if (verbosity <= 0) {
        return;
    }
    if (verbosity == 1) {
        errs.println(msg
                + " at line " + reader.getLineNumber()
                + " column " + tokenStart);
        return;
    }
    errs.println(msg
            + " at line " + reader.getLineNumber()
            + " column " + tokenStart
            + ":");
    if (lineStr != null) {
        errs.println(lineStr);
        for (int i=0; i<tokenStart; i++) {
            errs.print(lineStr.charAt(i) == '\t' ? '\t' : ' ');
        }
        errs.println("^");
    }
    if (verbosity < 3) {
        return;
    }
    if (lookaheads) {
        int[] valid = validTokens(state);
        String emsg =
            (lookahead == LEX_ERROR)
                ? ("" + lval)
                : tokenName(lookahead);
        if (valid.length > 0) {
            errs.print("Expecting ");
            for (int i=0; i<valid.length; i++) {
                if (i > 0) {
                    errs.print(i == valid.length - 1 ? ", or " : ", ");
                }
                errs.print(tokenName(valid[i]));
            }
            errs.println(", but found " + emsg);
        } else {
            errs.println("Invalid token " + emsg);
        }
    }
} // error(String,boolean)

/** Print a message, decorated with the current line and column number.
 * @param msg the message to print.
 */
/*package*/ void printMessage(String msg) {
    if (verbosity <= 0) {
        return;
    }
    errs.println(msg
                + " at line " + reader.getLineNumber()
                + " column " + tokenStart);
} // printMessage(String)
} // Parser
//line 1938 "Parser.java"
