%{
/* **************************Copyright-DO-NOT-REMOVE-THIS-LINE**
 * Condor Copyright Notice
 *
 * See LICENSE.TXT for additional notices and disclaimers.
 *
 * Copyright (c)1990-2005 Condor Team, Computer Sciences Department,
 * University of Wisconsin-Madison, Madison, WI.  All Rights Reserved.
 * Use of the CONDOR Software Program Source Code is authorized
 * solely under the terms of the Condor Public License (see LICENSE.TXT).
 * For more information contact:
 * CONDOR Team, Attention: Professor Miron Livny,
 * 7367 Computer Sciences, 1210 W. Dayton St., Madison, WI 53706-1685,
 * (608) 262-0856 or miron@cs.wisc.edu.
 * ***************************Copyright-DO-NOT-REMOVE-THIS-LINE**/

package condor.classad;
import java.io.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
/** This is the internal classad parser generated by byacc.  From outside
 * this package, it should be accessed through the wrapper class ClassAdParser.
 * @see ClassAdParser
 * @author <a href="mailto:solomon@cs.wisc.edu">Marvin Solomon</a>
 * @version 2.0
 */
class Parser {
%}
%token ERROR
%token FALSE
%token IDENTIFIER
%token INTEGER
%token LEX_ERROR
%token REAL
%token STRING
%token TRUE
%token UNDEFINED

%left OP_LOR
%left OP_LAND
%left '|'
%left '^'
%left '&'
%left OP_EQ OP_NE OP_IS OP_ISNT
%left '<' '>' OP_LE OP_GE
%left OP_SHL OP_SHR OP_SHRR
%left '+' '-'
%left '*' '/' '%' 
%left UNARY

%type <Expr> Expr Expression PrefixExpr SuffixExpr Atom Literal Call
%type <RecordExpr> Record
%type <ListExpr> List
%type <List> ListBody DefinitionList
%type <AttrName> Identifier IDENTIFIER
%type <Constant> Strings STRING REAL INTEGER

%start Expression

%%
Expression
    : Expr 
    | Expr '?' Expression ':' Expression { $$ = new CondExpr($1, $3, $5); }
    ;
Expr
    : Expr OP_LOR Expr  { $$ = new Op(Expr.OR, $1, $3); }
    | Expr OP_LAND Expr  { $$ = new Op(Expr.AND, $1, $3); }
    | Expr '|' Expr  { $$ = new Op(Expr.BITOR, $1, $3); }
    | Expr '^' Expr  { $$ = new Op(Expr.BITXOR, $1, $3); }
    | Expr '&' Expr  { $$ = new Op(Expr.BITAND, $1, $3); }
    | Expr OP_EQ Expr  { $$ = new Op(Expr.EQUAL, $1, $3); }
    | Expr OP_NE Expr  { $$ = new Op(Expr.NOT_EQUAL, $1, $3); }
    | Expr OP_IS Expr  { $$ = new Op(Expr.SAME, $1, $3); }
    | Expr OP_ISNT Expr  { $$ = new Op(Expr.DIFFERENT, $1, $3); }
    | Expr '<' Expr  { $$ = new Op(Expr.LESS, $1, $3); }
    | Expr '>' Expr  { $$ = new Op(Expr.GREATER, $1, $3); }
    | Expr OP_LE Expr  { $$ = new Op(Expr.LESS_EQ, $1, $3); }
    | Expr OP_GE Expr  { $$ = new Op(Expr.GREATER_EQ, $1, $3); }
    | Expr OP_SHL Expr  { $$ = new Op(Expr.LEFT_SHIFT, $1, $3); }
    | Expr OP_SHR Expr  { $$ = new Op(Expr.RIGHT_SHIFT, $1, $3); }
    | Expr OP_SHRR Expr  { $$ = new Op(Expr.URIGHT_SHIFT, $1, $3); }
    | Expr '+' Expr  { $$ = new Op(Expr.PLUS, $1, $3); }
    | Expr '-' Expr  { $$ = new Op(Expr.MINUS, $1, $3); }
    | Expr '*' Expr { $$ = new Op(Expr.TIMES, $1, $3); }
    | Expr '/' Expr  { $$ = new Op(Expr.DIV, $1, $3); }
    | Expr '%' Expr  { $$ = new Op(Expr.MOD, $1, $3); }
    | PrefixExpr
    ;
PrefixExpr
    : SuffixExpr
    | '+' PrefixExpr %prec UNARY { $$ = new Op(Expr.UPLUS, $2); }
    | '-' PrefixExpr %prec UNARY { $$ = new Op(Expr.UMINUS, $2); }
    | '!' PrefixExpr %prec UNARY { $$ = new Op(Expr.NOT, $2); }
    | '~' PrefixExpr %prec UNARY { $$ = new Op(Expr.BIT_COMPLEMENT, $2); }
    ;
SuffixExpr
    : Atom
    | SuffixExpr '.' Identifier { $$ = new SelectExpr($1,  $3); }
    | SuffixExpr '[' Expression ']' { $$ = new SubscriptExpr($1, $3); }
    ;
Atom
    : Identifier { $$ = new AttrRef($1); }
    | Literal
    | List { $$ = $1; }
    | Record { $$ = $1; }
    | Call { $$ = $1; }
    | '(' Expression ')' { $$ = $2; }
    ;
List
    : '{' ListBody ListEnd { $$ = new ListExpr($2); }
    | '{' ListEnd { $$ = new ListExpr(null); }
    ;
ListEnd
    : '}'
    | ',' '}'
    ;
ListBody
    : Expression { List l = new ArrayList(); l.add($1); $$ = l; }
    | ListBody ',' Expression { List l = $1; l.add($3); $$ = l; }
    ;
Record
    : '[' DefinitionList RecordEnd {
        List l = $2;
        RecordExpr r = new RecordExpr(l.size());
        for (Iterator i = l.iterator(); i.hasNext(); ) {
            AttrName n = (AttrName) i.next();
            if (n.equals(AttrName.PARENT)) {
                error("Attribute name \"parent\" is reserved", false);
                i.next();
                continue;
            }
            Expr e = (Expr) i.next();
            if (r.lookup(n) != null) {
                error("Duplicate definition of attribute " + n + " in Record",
                    false);
            } else {
                r.insertAttribute(n, e);
            } /* if */
        } /* for */
        $$ = r;
    }
    | '[' RecordEnd { $$ = new RecordExpr(); }
    ;
RecordEnd
    : ']'
    | ';' ']'
    ;
DefinitionList
    : Identifier '=' Expression {
        List l = new ArrayList();
        l.add($1);
        l.add($3);
        $$ = l;
    }
    | DefinitionList ';' Identifier '=' Expression {
        List l = $1;
        l.add($3);
        l.add($5);
        $$ = l;
    }
    ;
Call
    : Identifier '(' ListBody ')' { $$ = FuncCall.getInstance($1, $3); }
    | Identifier '(' ')' { $$ = FuncCall.getInstance($1, new ArrayList()); }
    ;
Literal
    : REAL { $$ = $1; }
    | Strings { $$ = $1; }
    | INTEGER { $$ = $1; }
    | TRUE { $$ = Constant.TRUE; }
    | FALSE { $$ = Constant.FALSE; }
    | UNDEFINED { $$ = Constant.Undef; }
    | ERROR { $$ = Constant.Error; }
    ;
Strings
    : STRING
    | Strings STRING {
        $$ = Constant.getInstance($1.stringValue() + $2.stringValue());
    }
    ;
Identifier
    : IDENTIFIER
    ;
%%
private static String VERSION = "$Id: classad.y,v 1.26 2005/05/06 20:54:07 solomon Exp $";

/** Verbosity for error messages.
 * Values are:
 * 0 - no messages
 * 1 - only show message and line number
 * 2 - also echo line in question
 * 3 - also list tokens expected
 */
/*package*/ int verbosity = 3;

/** Place to send error messages.  Default is System.err. */
/*package*/ PrintStream errs = System.err;

/** Create a parser for parsing input from a Reader.
 * @param rdr the source of the input characters.
 */
public Parser(Reader rdr) {
    reader = new LineNumberReader(rdr);
} // Parser(Reader)

/** Create a parser for parsing input from an InputStream.
 * @param str the source of the input characters.
 */
public Parser(InputStream str) {
    reader = new LineNumberReader(new InputStreamReader(str));
} // Parser(InputStream)

/** Create a parser for parsing a String.
 * @param str the source of the input characters.
 */
public Parser(String str) {
    reader = new LineNumberReader(new StringReader(str));
} // Parser(String)

/** Supply a new source of input to this Parser.
 * @param rdr the new source of input.
 */
public void reset(Reader rdr) {
    reader = new LineNumberReader(rdr);
    lookahead = -1;
} // reset(Reader)

/** Supply a new source of input to this Parser.
 * @param str the new source of input.
 */
public void reset(InputStream str) {
    reader = new LineNumberReader(new InputStreamReader(str));
    lookahead = -1;
} // reset(InputStream)

/** Supply a new source of input to this Parser.
 * @param str the new source of input.
 */
public void reset(String str) {
    reader = new LineNumberReader(new StringReader(str));
    lookahead = -1;
} // reset(String)

/** Returns the current input line.
 * @return the current line number.
 */
public int curLine() {
    if (reader == null) {
        return 0;
    }
    return reader.getLineNumber();
} // curLine()

/** Returns the current input column.
 * @return the current line number.
 */
public int curColumn() {
    return tokenStart + 1;
} // curColumn()

// Lex support

/** Stream from which lex reads input.  */
private LineNumberReader reader;

/** The current input line. */
private String lineStr;

/** A version of lineStr unpacked into an array for speedy access */
private char[] line = new char[100];

/** The number of characters in the current input line. */
private int lineLen;

/** The current position in the current input line (0 = start of line) */
private int pos;

/** The position in the current line where the current token started. */
private int tokenStart;

/** The next input character to be consumed.  */
private int curChar;

/** A table of reserved words. */
private static final String[] reserved = {
    null,
    "error",
    "false",
    "is",
    "isnt",
    "true",
    "undefined",
};

/** A table of token codes parallel to the array reserved. */
private static final int[] reservedCode = {
    0, // unused
    ERROR,
    FALSE,
    OP_IS,
    OP_ISNT,
    TRUE,
    UNDEFINED
};

/** A trie constructed from the reserved words.
 * Three parallel arrays.  The element match[j] is supposed to match the
 * next letter of the input string.  If accept[j] = n != 0, then the string
 * matched thus far is reserved word n.  If the match[j] does not match
 * the next input character and alt[j] = n != 0, try match[n] instead.
 * If the input string starts with letter c, then start matching at position
 * trieStart[c], provided trieStart[c] > 0.
 * <p>
 * Why not simply use a HashMap, you ask?  Because that would require
 * allocating a new String object for each identifier in the input, just to see
 * if it is a reserved word.  With this setup, we can quickly check whether
 * a region in the array "char line[]" is a reserved word without any
 * storage allocation or garbage collection.  As a bonus, we also get
 * case-independent maching.
 */
private static char[] match;
private static int[] accept;
private static int[] alt;
private static int[] trieStart;
static {
    // Inidialize the trie data structure
    int len = 1;
    for (int i = 1; i < reserved.length; i++) {
        len += reserved[i].length() + 1;
    }
    trieStart = new int['z' + 1];
    match = new char[len];
    alt = new int[len];
    accept = new int[len];
    Arrays.fill(match, ' ');

    int next = 1;
    for (int i = 1; i < reserved.length; i++) {
        next = trieAdd(i, next);
    }
}; // static

/** A "wired-in" version of Character.toLowerCase(c) to avoid the
 * overhead in the common case of ASCII (c < 128).
 * 'A' -> 'a', 'a' -> 'a', '0' -> '0', '_' -> '_', and all other characters map
 * to zero.
 * <br>
 * Note: this table is only used for recognizing reserved words, which contain
 * only letters (no digits, underscores, etc.)  However, it maps digits and
 * underscores to themselves be cause the end of a reserved_word candidate is
 * recognized by a character c such that tolower[c] == 0.  Thus, for example,
 * "is_empty" is recognized as a non-reserved identifier because the underscore
 * is part of the word (tolower['_'] == '_') but the prefix "is_" fails the
 * trie-match algorithm.  See reservedLookup().
 */
private static final int[] tolower = new int[] {
       0,   0,   0,   0,   0,   0,   0,   0, /*   0 */
       0,   0,   0,   0,   0,   0,   0,   0, /*   8 */
       0,   0,   0,   0,   0,   0,   0,   0, /*  16 */
       0,   0,   0,   0,   0,   0,   0,   0, /*  24 */
       0,   0,   0,   0,   0,   0,   0,   0, /*  32 */
       0,   0,   0,   0,   0,   0,   0,   0, /*  40 */
      48,  49,  50,  51,  52,  53,  54,  55, /*  48 */
      56,  57,   0,   0,   0,   0,   0,   0, /*  56 */
       0,  97,  98,  99, 100, 101, 102, 103, /*  64 */
     104, 105, 106, 107, 108, 109, 110, 111, /*  72 */
     112, 113, 114, 115, 116, 117, 118, 119, /*  80 */
     120, 121, 122,   0,   0,   0,   0,  95, /*  88 */
       0,  97,  98,  99, 100, 101, 102, 103, /*  96 */
     104, 105, 106, 107, 108, 109, 110, 111, /* 104 */
     112, 113, 114, 115, 116, 117, 118, 119, /* 112 */
     120, 121, 122,   0,   0,   0,   0,   0  /* 120 */
};

/** Prints a message indicating that some particular event occurred at a given
 * point in the input.
 * @param msg the message.
 */
private void lexdebug(Object msg) {
    System.out.println("LEX: line " + reader.getLineNumber()
        + " column " + (tokenStart+1)
        + " " + msg);
} // lexdebug(Object)

    /** Helps to build the trie by adding reserved[n].
     * @param n the reserved-word code (index into reserved[]).
     * @param next the next free slot in parallel arrays (match,alt,accept).
     * @return the first slot in the parallel arrays not used by this
     * procedure.
     */
    private static int trieAdd(int n, int next) {
        String s = reserved[n];
        int pos;
        char c = s.charAt(0);
        if (trieStart[c] == 0) {
            trieStart[c] = next;
            trieStart[Character.toUpperCase(c)] = next;
            pos = next;
        } else {
            pos = trieStart[c];
        }
        for (int i = 0; i < s.length(); i++) {
            c = s.charAt(i);
            if (match[pos] == ' ') {
                match[pos++] = c;
            } else if (match[pos] == c) {
                pos++;
            } else {
                alt[pos] = next;
                pos = next;
                match[pos++] = c;
            }
        }
        accept[pos++] = n;
        if (pos > next) {
            next = pos;
        }
        return next;
    } // trieAdd(int,int)

/** Tests whether a character is "whitespace".
 * As of Java 1.4, there appear to be several incompatible notions of
 * "whitespace":
 * <ul>
 * <li>According to the Java Language Specification (Second Edition), Sections
 *     3.4 and 3.6, whitespace includes only the ASCII SPACE character (32),
 *     as well as Horizontal Tab (9), Linefeed (10), Formfeed (12),
 *     and Carriage Return (13) [all code points listed here are in decimal].
 * <li>The method Character.isSpace accepts the same set of characters.
 *     It is, however, deprecated.  The documentation says to use isWhitespace
 *     instead.
 * <li>The regular expression escape \s in java.util.regex matches all
 *     character satisfying Character.isSpace, plus the character Vertical Tab
 *     (11).
 * <li>Character.isWhitespace adds to this set the ASCII characters Field
 *     Separator (28), Group Separator (29), Record Separator (30), and Unit
 *     Separator (31), as well as several Unicode characters with values
 *     greater than 256.
 * </ul>
 * The classad language specification currently uses the same definition as
 * \s:  codes 9-13 and 32 (decimal).
 *
 * @param c a character code.
 * @return true if c is a character in the range 9-13 or 32 (decimal).
 */
private static final boolean isSpace(char c) {
    return c == 32 || (c >= 9 && c <= 13);
} // isSpace(char)

/** Get the "lookahead" token: the first token not yet consumed by the
 * parser.
 * The token is not removed from the input stream.
 * @return the code for the next token.
 * @see #getNextToken()
 */
public int nextToken() {
    if (lookahead < 0) {
        lookahead = lex();
    }
    return lookahead;
} // nextToken()

/** Get the value associated with the "lookahead" token: the first token not
 * yet consumed by the parser.
 * The token is not removed from the input stream.
 * @return the value associated with the next token.
 * @see #nextToken()
 */
public Object nextValue() {
    if (lookahead < 0) {
        lookahead = lex();
    }
    return lval;
} // nextValue()

/** Get and remove the "lookahead" token: the first token not yet consumed
 * by the parser.
 * The token is removed from the input stream.
 * @return the code for the next token.
 * @see #getNextToken()
 */
public int getNextToken() {
    if (lookahead < 0) {
        lookahead = lex();
    }
    int result = lookahead;
    lookahead = -1;
    return result;
} // getNextToken()

/** Gets the next line from reader and unpacks it to the array line[].
 * @return -1 for errors, 0 for EOF, or 1 for success.
 */
private final int getLine() {
    try {
        lineStr = reader.readLine();
    } catch (IOException e) {
        e.printStackTrace();
        return -1;
    }
    if (lineStr == null) {
        return 0; // EOF
    }

    lineLen = lineStr.length();
    
    if (line.length < lineLen + 1) {
        line = new char[lineLen + 20];
    }
    lineStr.getChars(0,lineLen,line,0);
    pos = 0;
    line[lineLen] = ' ';
    return 1;
} // getLine()

/** Check whether the word stored in the line[] array starting at position
 * tokenStart matches one of the reserved words.  If so, return its index
 * in the array reserved[].  Otherwise, return 0.
 * @return an index in reserved[] or 0.
 */
private final int reservedLookup() {
    // Find the starting point in the trie
    int c = line[tokenStart];
    if (c >= trieStart.length) {
        return 0;
    }
    int triePos = trieStart[c];
    if (triePos++ == 0) {
        return 0;
    }
    // Start matching with the second character of the input
    for (int i = tokenStart+1; ;i++) {
        c = line[i];
        if (c >= tolower.length || (c = tolower[c]) == 0) {
            // Next character is not a letter.  If accept[triePos] is non-zero,
            // what we've seen up to now is a reserved word.  Otherwise,
            // it is (part of) an identifier.  In either case, we just
            // return accept[triePos].
            return accept[triePos];
        }
        while (match[triePos] != c) {
            // Match failed.  See if there is an alternative match at this
            // point (sibling node in the trie).
            triePos = alt[triePos];
            if (triePos == 0) {
                // No alternative.  No match.
                return 0;
            }
        }
        // Successfully matched one more charcter of input.
        triePos++;
    }
} // reservedLookup()

/** The lexical scanner.
 * It finds the next token in the input stream and returns its token code.
 * It also sets the fields tokenStart and pos so that the text of the token
 * is in line[tokenStart ... pos-1]. (For efficiency reasons, we do not
 * return the text as a String, since that would entail allocation a new String
 * that would, in most cases, immediately become garbage.)  
 * The "semantics" associated with the current token (if any) is stored
 * in lval.
 * <p>
 * @return the token code for the next token; 0 for EOF; LEX_ERROR for error.
 */
private int lex() {
    int n;
    char quote;

    lval = null;
    // Skip spaces and comments
    for (;;) {
        if (pos == lineLen || (line[pos] == '/' && line[pos+1] == '/')) {
            if ((n = getLine()) <= 0) {
                return n;
            }
            continue;
        }
        if (line[pos] == '/' && line[pos+1] == '*') {
            for (pos += 2;;pos++) {
                if (pos >= lineLen) {
                    if ((n = getLine()) <= 0) {
                        return n;
                    }
                    pos = -1;
                    continue;
                }
                if (pos < lineLen - 1
                        && line[pos] == '*'
                        && line[pos+1] == '/')
                {
                    pos += 2;
                    break;
                }
            }
            continue;
        }
        if (!isSpace(line[pos])) {
            break;
        }
        pos++;
    }
    tokenStart = pos;

    // Identifier or reserved word
    if (Character.isJavaIdentifierStart(line[pos])) {
        do {
            pos++;
        } while (Character.isJavaIdentifierPart(line[pos]));
        int i = reservedLookup();
        if (i > 0) {
            if (tracing) {
                lexdebug("reserved word " + reservedCode[i]
                         + " (" + reserved[i] + ")");
            }
            return reservedCode[i];
        }
        lval = AttrName.fromString(
                    new String(line, tokenStart, pos - tokenStart));
        if (tracing) {
            lexdebug("ID(" + lval + ")");
        }
        return IDENTIFIER;
    }

    // Number or '.'
    if (Character.isDigit(line[pos]) || line[pos]=='.') {
        // Number or lone '.'
        int type;
        if (line[pos] == '.' && !Character.isDigit(line[pos+1])) {
            pos++;
            if (tracing) {
                lexdebug("DOT");
            }
            return '.';
        }
        // Accumulate leading digits
        for (; Character.isDigit(line[pos]); pos++) {
        }
        if (line[pos] == '.') {
            // There is a decimal point.  Grab the fraction part if any.
            type = REAL;
            for (pos++; Character.isDigit(line[pos]); pos++) {
            }
        } else {
            // There was no decimal point.  For now, assume it is an
            // integer.
            type = INTEGER;
            if (line[tokenStart] == '0'
                && (line[tokenStart+1] == 'x' || line[tokenStart+1] == 'x'))
            {
                // A hex integer constant.  Note that 'e' and 'E' are hex
                // digits, so 0x123e12 is parsed as a hex integer, and
                // and 0x123e+12 is parsed as three tokens: 0x123e + 12
                int value = 0;
                int digitValue;
                for (pos = tokenStart+2;
                    (digitValue = Character.digit(line[pos],16)) >= 0;
                    pos++)
                {
                    value = (value << 4) + digitValue;
                }
                // There must be at least one digit
                if (pos == tokenStart + 2) {
                    if (tracing) {
                        lexdebug("bad number");
                    }
                    lval = "hex constant with no digits("
                        + new String(line, tokenStart, pos - tokenStart)
                        + ")";
                    return LEX_ERROR;
                }
                lval = Constant.getInstance(value);
                if (tracing) {
                    lexdebug("INTEGER " + lval);
                }
                return INTEGER;
            }
        } // no decimal point
        // Now look for optional exponent part
        if (line[pos] == 'e' || line[pos] == 'E') {
            type = REAL;
            pos++;
            if (line[pos] == '+' || line[pos] == '-') {
                pos++;
            }
            if (!Character.isDigit(line[pos])) {
                // E[+-] must be followed by at least one digit
                if (tracing) {
                    lexdebug("bad float");
                }
                lval = "exponent with no digits("
                    + new String(line, tokenStart, pos - tokenStart)
                    + ")";
                return LEX_ERROR;
            }
            for (pos++; Character.isDigit(line[pos]); pos++) {
            }
        }
        // Finally, compute the value
        if (type == REAL) {
            lval = Constant.getInstance(
                        Double.parseDouble(
                            new String(line, tokenStart, pos - tokenStart)));
            if (tracing) {
                lexdebug("REAL " + lval);
            }
            return REAL;
        }
        // If there was no decimal point or exponent, we have to check
        // for a leading 0, meaning octal.
        int value = 0;
        int radix = (line[tokenStart] == '0') ? 8 : 10;
        for (int i=tokenStart; i<pos; i++) {
            int digitValue = Character.digit(line[i],radix);
            if (digitValue < 0) {
                if (tracing) {
                    lexdebug("bad oct");
                }
                lval = "octal constant with no octal digits("
                    + new String(line, tokenStart, pos - tokenStart)
                    + ")";
                return LEX_ERROR;
            }
            value = value * radix + digitValue;
        }
        lval = Constant.getInstance(value);
        if (tracing) {
            lexdebug("INT " + lval);
        }
        return INTEGER;
    } // Number

    // Multi-character operators
    switch (line[pos++]) {
    case '!':
        // != or !
        if (line[pos] == '=') {
            pos++;
            if (tracing) {
                lexdebug("NE");
            }
            return OP_NE;
        }
        break;
    case '&':
        // && or &
        if (line[pos] == '&') {
            pos++;
            if (tracing) {
                lexdebug("LAND");
            }
            return OP_LAND;
        }
        break;
    case '<':
        // << or <= or <
        if (line[pos] == '<') {
            pos++;
            if (tracing) {
                lexdebug("SHL");
            }
            return OP_SHL;
        }
        if (line[pos] == '=') {
            pos++;
            if (tracing) {
                lexdebug("LE");
            }
            return OP_LE;
        }
        break;
    case '=':
        // == or =
        if (line[pos] == '=') {
            pos++;
            if (tracing) {
                lexdebug("EQ");
            }
            return OP_EQ;
        }
        if (line[pos] == '?' && line[pos+1] == '=') {
            pos += 2;
            if (tracing) {
                lexdebug("IS");
            }
            return OP_IS;
        }
        if (line[pos] == '!' && line[pos+1] == '=') {
            pos += 2;
            if (tracing) {
                lexdebug("ISNT");
            }
            return OP_ISNT;
        }
        break;
    case '>':
        // >= or >> or >>> or >
        if (line[pos] == '=') {
            pos++;
            if (tracing) {
                lexdebug("GE");
            }
            return OP_GE;
        }
        if (line[pos] == '>') {
            pos++;
            if (line[pos] == '>') {
                pos++;
                if (tracing) {
                    lexdebug("SHRR");
                }
                return OP_SHRR;
            }
            if (tracing) {
                lexdebug("SHR");
            }
            return OP_SHR;
        }
        break;
    case '|':
        // || or |
        if (line[pos] == '|') {
            pos++;
            if (tracing) {
                lexdebug("LOR");
            }
            return OP_LOR;
        }
        break;
    case '"':
    case '\'':
        // String constant or quoted attribute name
        // Simply gather the characters up to an unescaped matching quote.
        // Other escape processing is done later.
        quote = line[pos - 1];
        for (;;) {
            if (pos == lineLen) {
                // Unterminated string constant or attribute name.
                lval = "unterminated "
                    + (quote == '"' ? "string " : "attribute name ")
                    + new String(line, tokenStart, pos - tokenStart);
                return LEX_ERROR;
            }
            if (line[pos] == '\\') {
                pos +=2 ;
                continue;
            }
            if (line[pos] == quote) {
                pos++;
                break;
            }
            pos++;
        }
        if (quote == '"') {
            int result = STRING;
            lval = Constant.getInstance(line, tokenStart + 1, pos - 1);
            if (lval == null) {
                lval = "invalid string "
                    + new String(line, tokenStart, pos - tokenStart);
                result = LEX_ERROR;
            }
            if (tracing) {
                lexdebug("STRING(" + lval + ")");
            }
            return result;
        } else {
            int result = IDENTIFIER;
            lval = AttrName.fromText(
                                new String(line, tokenStart, pos - tokenStart));
            if (lval == null) {
                lval = "invalid attribute name "
                    + new String(line, tokenStart, pos - tokenStart);
                result = LEX_ERROR;
            }
            if (tracing) {
                lexdebug("ID(" + lval + ")");
            }
            return result;
        }
    } // switch (line[pos++])
    // In all other cases, simply return the single character.  If it
    // isn't legit, the parser will catch it.
    if (tracing) {
        lexdebug("CHAR('" + line[pos-1] + "')");
    }
    return line[pos-1];
} // lex()

/** Print an error message, decorated with the current line and column number
 * and information about valid lookaheads.
 * @param msg the message to print.
 */
private void error(String msg) {
    error(msg, true);
} // error(String)

/** Print an error message, decorated with the current line and column number.
 * @param msg the message to print.
 * @param lookahead if true, indicate valid lookaheads.
 */
private void error(String msg, boolean lookaheads) {
    if (verbosity <= 0) {
        return;
    }
    if (verbosity == 1) {
        errs.println(msg
                + " at line " + reader.getLineNumber()
                + " column " + tokenStart);
        return;
    }
    errs.println(msg
            + " at line " + reader.getLineNumber()
            + " column " + tokenStart
            + ":");
    if (lineStr != null) {
        errs.println(lineStr);
        for (int i=0; i<tokenStart; i++) {
            errs.print(lineStr.charAt(i) == '\t' ? '\t' : ' ');
        }
        errs.println("^");
    }
    if (verbosity < 3) {
        return;
    }
    if (lookaheads) {
        int[] valid = validTokens(state);
        String emsg =
            (lookahead == LEX_ERROR)
                ? ("" + lval)
                : tokenName(lookahead);
        if (valid.length > 0) {
            errs.print("Expecting ");
            for (int i=0; i<valid.length; i++) {
                if (i > 0) {
                    errs.print(i == valid.length - 1 ? ", or " : ", ");
                }
                errs.print(tokenName(valid[i]));
            }
            errs.println(", but found " + emsg);
        } else {
            errs.println("Invalid token " + emsg);
        }
    }
} // error(String,boolean)

/** Print a message, decorated with the current line and column number.
 * @param msg the message to print.
 */
/*package*/ void printMessage(String msg) {
    if (verbosity <= 0) {
        return;
    }
    errs.println(msg
                + " at line " + reader.getLineNumber()
                + " column " + tokenStart);
} // printMessage(String)
} // Parser
